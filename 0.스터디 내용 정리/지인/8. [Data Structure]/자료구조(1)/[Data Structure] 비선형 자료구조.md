# 비선형 자료 구조

## 그래프

### 그래프란?

> 정점(Vertex)과 간선(Edge)의 집합으로, 사물이나 상태와 그 관계를 표현하는 비선형 자료구조.
> 방향성 유무, 가중치 유무, 다중 간선·자기 루프 허용 여부 등으로 분류된다.

- 표현
  - **인접 리스트**: 정점마다 인접 정점 목록 저장. 희소 그래프에서 메모리 효율적
  - **인접 행렬**: `V×V` 행렬. 간선 존재 여부 확인 O(1), 밀집 그래프와 행렬 연산에 유리
- 장단점
  - 장점: 관계 모델링에 유연하며, 경로·연결성·흐름 등 **풍부한 알고리즘** 보유
  - 단점: 표현과 알고리즘 선택에 따라 **메모리·시간 편차**가 크고, 구현이 복잡함

### 언제 그래프를 쓰나?

- **상태 관리**: UI 컴포넌트 간 의존성이나 상태 변화가 복잡할 때, 그래프 모델(특히 DAG) 구조 활용
- **라우팅**: SPA 라우팅에서 화면 간 이동/경로는 그래프의 경로 문제와 연결됨
- **추천 시스템**: 소셜 네트워크, 추천 기능 등에서 그래프 탐색 알고리즘(DFS, BFS)이 핵심

<br/>

## 트리

### 트리란?

> 사이클 없는 연결 그래프(무방향) 혹은 루트가 있는 방향 비순환 구조.
> 부모–자식 계층과 부분 문제 분해가 핵심이다.

- 특징: **N개 정점, N-1개 간선**, 계층·서브트리, 순회(**전위·중위·후위·레벨**)
- 장단점
  - 장점: **계층적 모델링**에 적합하며, 탐색·정렬·인덱싱의 **뼈대**
  - 단점: 균형 상실 시 성능 저하, 포인터 오버헤드

<br/>

### 언제 트리를 쓰나?

- **DOM 트리**: 프론트엔드에서는 HTML DOM이 트리 그 자체
- **상태 트리/리듀서**: Redux 등 글로벌 상태 관리에서도 트리 구조가 자주 나타남
- **컴포넌트 트리**: React 같은 라이브러리에서 컴포넌트 계층이 트리 형태

<br/>

### Binary Tree

> 각 노드가 최대 두 개의 자식 노드(왼쪽 자식과 오른쪽 자식)을 가질 수 있는 트리 구조

- 순회 방식: 전위 순회(Preorder), 중위 순회(Inorder), 후위 순회(Postorder), 레벨 순서 순회(Level-order)가 있으며, 특히 **중위 순회**는 이진 검색 트리(BST)에서 노드들을 정렬된 순서대로 출력하는 데 사용됨
- 요약: **2-way 분기** 구조의 기본 틀을 제공하며, 이진 검색 트리(BST), 힙(Heap), 세그먼트 트리(Segment Tree) 등 다양한 고급 자료 구조들의 기반이 되는 핵심 구조

<br/>

### Full Binary Tree

> 트리의 모든 노드가 자식 노드를 정확히 0개 또는 정확히 2개 갖는 이진 트리 구조

- 성질: **내부 노드(internal node)의 개수 = 리프 노드(leaf node)의 개수 - 1**이라는 수학적 관계 성립
- 요약: 구조적 제약 조건이 매우 강하기 때문에 알고리즘의 **복잡도 분석과 수학적 증명**을 수행할 때 자주 활용되는 특수한 형태의 이진 트리

<br/>

### Complete Binary Tree

> 마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있으며, 마지막 레벨의 노드들은 왼쪽부터 순서대로 빈틈없이 촘촘하게 채워진 이진 트리

- 성질: 트리의 높이는 **⌊log₂n⌋**이며, **배열 인덱싱** 방식을 사용하면 부모 노드와 자식 노드의 위치는 간단한 산술 연산으로 계산 가능
- 요약: **힙(Heap)** 자료구조가 이 완전 이진 트리 형태를 기본으로 사용하며, 배열 기반 구현 방식에 최적화되어 있어 메모리 효율성과 연산 속도 측면에서 뛰어난 성능을 보임

<br/>

### Binary Search Tree

> 각 노드의 값이 왼쪽 서브트리의 모든 값보다 크고 오른쪽 서브트리의 모든 값보다 작다는 규칙(좌 < 루트 < 우)을 만족하는 순서가 있는 트리 구조

- 장단점
  - 장점: 트리 구조 자체가 **정렬된 상태를 유지**하므로, **범위 질의(range query)**를 효율적으로 수행할 수 있으며, 중위 순회를 통해 정렬된 순서로 모든 원소 출력 가능
  - 단점: 트리가 한쪽으로 **편향**되면 탐색 시간이 **O(n)**으로 악화될 수 있으며, 이는 균형 트리 기법(**AVL 트리, Red-Black 트리** 등)을 통해 보완
- 요약: **정렬된 상태 유지와 함께 동적인 삽입·삭제** 연산이 모두 필요한 상황에서 사용되는 범용적인 검색 트리 자료구조

<br/>

## 힙

> 우선순위(키) 기준으로 부모가 자식보다 항상 우선인 완전 이진 트리.
> 최소 힙과 최대 힙 두 종류가 있다.

- 연산
  - 삽입: 말단 추가 + **상향 힙화** → **O(log n)**
  - 삭제(루트): 루트 반환 + 말단을 루트로 올려 **하향 힙화** → **O(log n)**
  - 최솟값·최댓값 조회: **O(1)**
- 장단점
  - 장점: **우선 원소 추출**에 최적, **정렬(힙정렬)** 가능
  - 단점: **임의 삭제·검색**은 **O(n)**, 정렬 안정성 없음

<br/>

## 우선순위 큐

> 원소마다 우선순위를 부여하고, 가장 높은(또는 낮은) 우선순위를 먼저 꺼내는 ADT(Abstract Data Type)
> 힙으로 구현하는 것이 표준이다.

- 연산: `insert` **O(log n)**, `extract-top` **O(log n)**, `peek` **O(1)**
- 대안 구현: **이진·페어링·피보나치 힙**, **정렬 배열·리스트**(트레이드오프 다름)
- 활용: **스케줄링**, **다익스트라**, **이벤트 시뮬레이션**, **K-정렬 스트림**

<br/>

## 맵(Map)

> 키 → 값 연관 컨테이너. 키는 고유하다.

- 구현
  - **해시 맵**(평균): `get/set/delete` **O(1)**, 순서 비보장(언어별 차이)
  - **균형 검색 트리**: 연산 **O(log n)**, **정렬 순회** 지원
- 장단점
  - 장점: **키 기반 임의 접근**이 빠르고, API 단순
  - 단점: 해시 충돌·리사이즈 비용, 트리는 상수 계수가 큼

<br/>

## 셋(Set)

> 중복 없는 원소 집합. 수학적 집합 연산(합집합·교집합 등)에 대응한다.

- 구현: **해시 셋**(평균 **O(1)** 포함 검사), **트리 셋**(**O(log n)**, 정렬·범위)
- 연산: `add`, `has`, `delete`, **크기**, 집합 연산

<br/>

## 해시 테이블

> 해시 함수로 키를 인덱스(버킷)에 매핑해 평균 O(1) 접근을 제공하는 구조.

- 핵심
  - **해시 함수**: 균일 분포·빠름·충돌 최소화
  - **충돌 해결**: **체이닝(버킷 리스트)**, **개방 주소법(선형·이차·이중 해싱)**
  - **부하율(Load factor)** 관리: 리사이즈·재해싱으로 성능 유지
- 장단점
  - 장점: 평균적으로 **빠른 삽입·조회·삭제**, 구현 단순(체이닝)
  - 단점: **최악 O(n)** 가능, **순서·범위 질의** 부적합, **해시 선택**이 성능 좌우
