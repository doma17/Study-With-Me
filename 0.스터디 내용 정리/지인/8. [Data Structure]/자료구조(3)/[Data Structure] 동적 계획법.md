# 동적계획법 (Dynamic Programming)

## 개요

동적계획법(DP)은 하나의 큰 문제를 여러 개의 작은 문제로 나누어 해결하는 알고리즘 설계 기법입니다.

작은 문제들의 계산 결과를 저장해두었다가 큰 문제를 해결할 때 재활용합니다.

최적화 이론의 한 기술로, 특정 알고리즘이 아닌 문제 해결 패러다임입니다.

<br/>

## DP를 쓰는 이유

일반적인 재귀(Naive Recursion) 방식도 DP처럼 문제를 나누어 해결하지만, **동일한 부분 문제를 여러 번 반복 계산**하기 때문에 비효율적입니다.

피보나치 수열을 예로 들어봅시다.

1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144 …

피보나치 수를 재귀로 구현하면 **`f(n) = f(n-1) + f(n-2)`** 와 같은 식이 됩니다.

하지만 **`f(n-1)`**과 **`f(n-2)`**를 계산할 때 동일한 하위 함수가 여러 번 호출되어, 계산량이 기하급수적으로 늘어납니다.

즉, **`f(n-1)`**에서 계산한 값을 **`f(n-2)`**에서 또 다시 계산하는 비효율이 발생합니다.

![](https://blog.kakaocdn.net/dna/t3PF0/btqSgLZbXTp/AAAAAAAAAAAAAAAAAAAAAETm90hgWpL-K1qfYhR7v1TJURb4tI6pCfS4zllWhYqE/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=ULJnzcZojfSmys8CiS%2BZOd%2FIooI%3D)

만약 **한 번 계산한 결과를 저장해두고 재사용**한다면 어떨까요?

중복 계산이 제거되어, 100번째 피보나치 수도 약 200회 이내로 계산할 수 있습니다.

이처럼 DP를 적용하면 문제 해결이 훨씬 효율적으로 바뀌며, 보통 시간 복잡도는 다음과 같이 개선됩니다.

O(n²) → O(n) 수준 (문제에 따라 다름)

<br/>

## DP의 사용 조건

DP가 적용되려면 다음 2가지 조건을 만족해야 합니다.

**1) Overlapping Subproblems(겹치는 부분 문제)**

**2) Optimal Substructure(최적 부분 구조)**

**① Overlapping Subproblems**

DP는 문제를 여러 개의 작은 문제로 나눈 뒤, **그 결과를 재활용**합니다.

따라서 동일한 부분 문제가 반복해서 나타나는 경우에만 사용할 수 있습니다.

예를 들어, 피보나치 수열을 다시 살펴보면

**`f(3)`**, **`f(2)`**, **`f(1)`**처럼 **중복되는 부분 문제**가 여러 번 등장합니다.

이때, 한 번 계산한 값을 저장해두고 다시 사용할 수 있습니다.

반면 이진 탐색은 한 번의 탐색으로 원하는 값을 찾으면 종료하기 때문에, **부분 문제 재사용이 불가능**합니다.

따라서 DP를 적용할 수 없습니다.

**② Optimal Substructure(최적 부분 구조)**

**부분 문제의 최적 해가 전체 문제의 최적 해를 구성하는 경우**를 말합니다.

다시 말해, 작은 문제의 해를 결합하면 전체 문제의 최적 해가 일정하게 구해져야 합니다.

예를 들어, A에서 B까지의 **최단 경로**를 찾을 때,

중간 지점 X가 있다면 A—X와 X—B 각각이 최단 경로일 경우, 전체 최단 경로 A—X—B도 역시 최적입니다.

이처럼 부분 문제의 최적 해가 전체 해로 연결될 때 DP를 사용할 수 있습니다.

피보나치 수열 역시 이전 계산값을 그대로 사용해 전체 값을 결정하므로 최적 부분 구조를 가집니다.

<br/>

## **DP 사용하기**

DP는 다양한 문제에 적용할 수 있는 **방법론**입니다.

DP로 풀 수 있는 문제인지 판단하고, 코드를 작성하는 과정까지 단계별로 접근합니다.

### 단계 1) DP로 풀 수 있는 문제인지 확인

이 단계가 가장 어렵습니다.

문제를 작은 부분 문제로 나눠 표현할 수 있는지, 그리고 앞서 설명한 두 가지 조건을 만족하는지 판단해야 합니다.

일반적으로 **최대값/최소값 문제, 개수 세기 문제, 확률 문제** 등은 DP로 해결 가능한 경우가 많습니다.

### 단계 2) 문제의 변수 파악

DP에서는 결과를 좌우하는 **변수(state)**를 파악해야 합니다.

피보나치 수열에서는 n번째 값을 구하므로 변수는 n 하나입니다.

편집 거리(Edit Distance) 문제에서는 문자열의 길이 차이를 기준으로, 두 변수(문자열 1과 2의 인덱스)를 사용합니다.

0-1 배낭 문제(Knapsack)에서는 **물건의 인덱스와 무게** 두 변수가 중심이 됩니다.

### 단계 3) 변수 간 관계식 만들기 (점화식)

문제의 변수들이 서로 어떤 관계를 가지는지 정의해야 합니다.

이 관계를 **점화식(recurrence relation)**이라 합니다.

피보나치 수열의 경우, **`f(n) = f(n-1) + f(n-2)`**가 대표적인 예입니다.

점화식을 통해 코드가 작은 반복이나 재귀로 자동적으로 전체 문제를 해결하게 됩니다.

### 단계 4) 메모하기 (Memoization)

이제 변수 값에 따른 결과를 저장해야 합니다.

결과를 저장해두고 다시 사용할 수 있도록 하는 과정을 **메모이제이션(Memoization)**이라고 합니다.

보통 1차원이나 2차원 배열을 만들어 계산된 값을 저장합니다.

### 단계 5) 기저 상태(Base Case) 파악하기

가장 작은 단위의 문제, 즉 **기저 상태**를 정의해야 합니다.

피보나치 수열에서는 **`f(0) = 0`**, **`f(1) = 1`**이 기저 상태입니다.

이를 미리 저장해두면 이후 계산이 가능합니다.

문제에 따라 이 단계가 가장 복잡할 수 있습니다.

### 단계 6) 구현하기

DP는 구현 방식에 따라 두 가지로 구분됩니다.

- (1) Bottom-Up 방식
  작은 문제부터 차례로 계산하여 큰 문제를 푸는 방법입니다.
  기저 상태 **`dp[0]`**부터 시작하여 반복문으로 **`dp[n]`**까지 쌓아갑니다.
  이 과정을 **Tabulation**이라고 하며, 테이블을 채우듯 결과를 저장하기 때문에 붙은 이름입니다.
  핵심은 **값을 미리 계산해 배열에 저장하고, 필요한 곳에서 바로 참조**하는 것입니다.
- (2) Top-Down 방식
  **`dp[0]`**에서 시작하는 대신, 찾고자 하는 최종 값 **`dp[n]`**을 기준으로 문제를 아래로 내려가며 푸는 방식입니다.
  즉, **`f(n)`**을 구하기 위해 **`f(n-1)`**과 **`f(n-2)`**를 재귀 호출하는 것입니다.
  이때, 이미 계산한 값이 있다면 저장된 결과를 즉시 불러옵니다.
  이러한 형태의 DP를 **메모이제이션(Memoization)**이라고 부릅니다.

이처럼 DP는 **중복 계산을 줄이고, 부분 문제의 해를 재활용해 효율적으로 전체 답을 구하는 기법**입니다.

<br/>
<br/>

> 참고
>
> - https://hongjw1938.tistory.com/47
