# REST API

REST API는 웹 상의 자원(Resource)을 효율적으로 다루고, 시스템 간 상호 운용성과 확장성을 극대화하기 위한 대표적인 아키텍처 스타일입니다.

'REST'(Representational State Transfer, 대표 상태 전송)는 클라이언트가 서버의 자원에 접근하고 이를 조작할 수 있게 하는 아키텍처 원칙 모음입니다.

일반적으로 HTTP 프로토콜을 기반으로 구현되며, 분산 하이퍼미디어 시스템을 안정적이고 일관되게 동작시키기 위한 원칙을 따릅니다.

<br/>

## REST API의 개념

REST의 가장 기본적인 아이디어는 '자원'과 '행위'를 명확히 분리하는 것입니다.

1. **자원 (Resource)**

   서버가 관리하는 모든 것을 의미합니다.

   각 자원은 고유한 식별자인 **URI**(Uniform Resource Identifier)를 통해 구별됩니다.

2. **행위 (Verb)**

   자원에 대해 수행하고자 하는 작업을 의미합니다.

   이는 **HTTP 메서드**(GET, POST, PUT, DELETE 등)로 표현됩니다.

즉, "자원은 URI로 지정하고, 행위는 HTTP 메서드로 표현한다"는 것이 REST의 핵심입니다.

- `GET /users/1` : 1번 사용자의 정보를 조회(GET)한다.
- `POST /users` : 새로운 사용자를 생성(POST)한다.

REST API는 이러한 원칙을 기반으로 서버와 클라이언트가 데이터를 표준화된 방식으로 주고받도록 설계된 인터페이스입니다.

<br/>

## REST 아키텍처의 핵심 제약 조건

### **1. 클라이언트-서버 구조**

REST 아키텍처는 클라이언트와 서버의 책임을 명확하게 분리합니다.

- **클라이언트**: 리소스를 요청하고 사용자 인터페이스(UI) 및 표현(Presentation)을 담당합니다.
- **서버**: 리소스의 보관, 비즈니스 로직 처리, 데이터 관리를 담당합니다.

이 분리 구조는 개발 조직의 역할 분리를 돕고, UI/플랫폼 교체 등 각 부분의 독립적인 발전과 유지보수성을 향상시킵니다.

### 2. 무상태성 (Stateless)

REST는 무상태성을 요구합니다.

즉, 서버는 클라이언트의 세션 상태나 이전 요청의 컨텍스트를 보존하지 않습니다.

- 모든 요청은 그 자체만으로 완결된 정보(인증 정보, 파라미터 등)를 포함해야 합니다.
- 이를 통해 서버는 클라이언트의 상태를 기억할 필요가 없어지므로, 수평 확장(Scale-out)이 매우 용이해집니다.
  또한 장애 발생 시 특정 서버에 세션을 고정할 필요가 없어 복구가 간단해집니다.

### 3. 캐시 처리 가능 (Cacheable)

REST는 HTTP의 캐시 메커니즘을 적극적으로 활용할 수 있어야 합니다.

- 서버는 응답 헤더(`Cache-Control`, `ETag` 등)를 통해 해당 응답이 캐싱 가능한지, 유효 기간은 얼마인지 등의 정책을 명확히 전달해야 합니다.
- 적절한 캐시 전략은 전체 네트워크 트래픽을 줄이고, 클라이언트의 응답 속도를 크게 개선합니다.

### 4. 계층화 구조 (Layered System)

클라이언트는 API 서버에 직접 연결될 수도 있지만, 그 사이에 프록시, 로드 밸런서, 게이트웨이, 보안 필터 등 다양한 중간 계층이 존재할 수 있습니다.

- 클라이언트는 이러한 중간 계층의 존재를 알 필요 없이 오직 최종 서버와 통신하는 것처럼 동작합니다.
- 각 계층은 독립적으로 확장·교체 가능하며, 이를 통해 보안 정책 강화, 로드 분산 등 시스템 전체의 품질을 계층적으로 향상시킬 수 있습니다.

### 5. 일관된 인터페이스 (Uniform Interface)

REST의 가장 핵심적인 원칙으로, API 전반에 걸쳐 일관된 인터페이스 규칙을 강제합니다.

이는 시스템을 단순화하고 결합도를 낮추며, 다음과 같은 4가지 세부 원칙으로 구성됩니다.

- **자원의 명확한 식별 (Identification of Resources)**
  모든 자원은 고유한 URI로 식별되어야 합니다.
      URI는 동사 대신 **명사**를 사용하며, 컬렉션은 복수형으로 표현하는 것이 일반적입니다.

      - `/users` : 사용자 컬렉션
      - `/users/42` : ID가 42인 특정 사용자
      - `/users/42/orders` : 사용자 42가 가진 주문 목록
- **표현을 통한 리소스 조작 (Manipulation via Representations)**
  클라이언트는 자원의 '표현'(예: JSON, XML)을 가지고 작업하며, 표준 HTTP 메서드를 통해 서버에 의도를 명확히 전달합니다. - **GET**: 리소스 조회 - **POST**: 리소스 생성 - **PUT / PATCH**: 리소스 전체 / 부분 수정 - **DELETE**: 리소스 삭제
- **자기 서술적 메시지 (Self-Descriptive Messages)**
  요청과 응답은 그 자체만 보고도 의미를 파악할 수 있어야 합니다.
      메시지 안에는 콘텐츠 타입(`Content-Type`), 인코딩 방식, 요청 의도, 결과 상태 코드 같은 메타데이터가 명확히 포함되어야 합니다.
- **HATEOAS (Hypermedia as the Engine of Application State)**
  서버가 단순히 데이터만 돌려주는 것이 아니라, **이후 가능한 동작(상태 전이)에 대한 링크까지 함께 제공**하는 방식입니다.
      예를 들어 주문 조회 응답에 '이 주문을 취소하려면 `/orders/{id}/cancel`로 DELETE 요청을 보내라'라는 링크를 포함하는 식입니다.

      이는 클라이언트가 서버의 상태를 동적으로 탐색할 수 있게 하여 양측의 결합도를 크게 낮춥니다.

<br/>

## REST API의 장점 요약

이러한 원칙을 준수하는 RESTful API는 다음과 같은 강력한 이점을 제공합니다.

- **상호 운용성**
  표준 HTTP를 기반으로 하므로 모든 플랫폼과 언어에서 쉽게 연동할 수 있습니다.
- **확장성**
  무상태성(Stateless)과 계층화 구조 덕분에 서버를 수평적으로 확장하기 매우 용이합니다.
- **유연성 및 유지보수성**
  클라이언트와 서버가 분리되어 있어, 서로 영향을 주지 않고 독립적으로 개발 및 배포가 가능합니다.
- **가시성 및 신뢰성**
  일관된 인터페이스와 자기 서술적 메시지 덕분에 API의 동작을 이해하기 쉽고 디버깅이 용이합니다.

<br/>
<br/>

> 참고
>
> - https://khj93.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-REST-API%EB%9E%80-REST-RESTful%EC%9D%B4%EB%9E%80
> - https://www.ibm.com/kr-ko/think/topics/rest-apis
> - https://www.redhat.com/ko/topics/api/what-is-a-rest-api
