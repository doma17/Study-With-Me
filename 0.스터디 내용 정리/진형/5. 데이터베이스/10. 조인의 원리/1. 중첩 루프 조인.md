## 데이터베이스 조인 방식: 중첩 루프 조인 (Nested Loop Join)

중첩 루프 조인(Nested Loop Join, NL Join)은 두 테이블을 조인할 때 사용되는 가장 기본적인 알고리즘입니다. 이름 그대로 프로그래밍의 **중첩 `for`문과 동일한 방식**으로 동작하여 한 테이블의 데이터를 기준으로 다른 테이블의 데이터를 하나씩 비교하며 조건에 맞는 행을 찾아 결합합니다.

### 1\. 동작 원리

중첩 루프 조인은 두 테이블 중 하나를 \*\*외부 테이블(Outer Table)\*\*로, 다른 하나를 \*\*내부 테이블(Inner Table)\*\*로 지정하여 처리합니다.

1.  **외부 테이블 선택**: 먼저 처리의 기준이 될 외부 테이블(Outer Table)을 선택하고, 첫 번째 행을 읽습니다.
2.  **내부 테이블 스캔**: 외부 테이블의 첫 번째 행에 대해 내부 테이블(Inner Table)의 **모든 행을 처음부터 끝까지 스캔**하면서 조인 조건이 맞는지 검사합니다.
3.  **조건 일치 시 결과 추가**: 조인 조건을 만족하는 행을 찾으면, 그 행을 결과 집합(Result Set)에 추가합니다.
4.  **반복**: 외부 테이블의 다음 행을 읽고, 다시 내부 테이블의 모든 행을 스캔하는 과정을 외부 테이블의 마지막 행까지 반복합니다.

#### 간단한 비유

> 두 개의 카드 덱(A, B)에서 같은 숫자의 카드를 찾는 것과 같습니다.
>
> 1.  먼저 A 덱에서 카드 한 장(예: '7')을 뽑습니다. (외부 테이블)
> 2.  뽑은 '7' 카드를 손에 든 채, B 덱의 모든 카드를 한 장씩 처음부터 끝까지 넘겨보며 '7' 카드가 있는지 찾습니다. (내부 테이블)
> 3.  B 덱에서 '7'을 찾으면, 두 카드를 함께 빼놓습니다.
> 4.  A 덱에서 다음 카드(예: '3')를 뽑고, 다시 B 덱 전체를 처음부터 살펴보는 과정을 반복합니다.

### 2\. 성능 및 특징

- **장점**:

    - 알고리즘이 단순하고 어떤 조건에서든 사용할 수 있습니다.
    - **외부 테이블의 크기가 작고**, **내부 테이블의 조인 컬럼에 인덱스(Index)가 잘 설정되어 있을 때** 매우 빠른 성능을 보입니다. 인덱스를 사용하면 내부 테이블 전체를 스캔할 필요 없이 특정 데이터만 바로 찾아갈 수 있기 때문입니다.
    - 조인 결과를 즉시 사용자에게 보여줄 수 있어 온라인 트랜잭션 처리(OLTP) 시스템에 유리합니다.

- **단점**:

    - **두 테이블이 모두 클 경우** 성능이 급격하게 저하됩니다. 외부 테이블의 모든 행에 대해 내부 테이블 전체를 반복적으로 스캔해야 하므로 처리량이 기하급수적으로 늘어납니다. (성능 = 외부 테이블 행 수 × 내부 테이블 행 수)
    - 내부 테이블의 조인 컬럼에 인덱스가 없으면 매번 테이블 전체를 스캔(Full Table Scan)해야 하므로 매우 비효율적입니다.

### 3\. 예시

다음과 같은 SQL 쿼리가 있을 때, 데이터베이스 옵티마이저는 중첩 루프 조인을 선택할 수 있습니다.

```sql
SELECT E.ENAME, D.DNAME
FROM EMP E
JOIN DEPT D ON E.DEPTNO = D.DEPTNO
WHERE E.JOB = 'SALESMAN';
```

- **옵티마이저의 판단**: `EMP` 테이블에서 `JOB = 'SALESMAN'` 조건을 만족하는 데이터가 적다고 판단하면, `EMP` 테이블을 **외부 테이블**로 선택합니다.
- **실행 과정**:
    1.  `EMP` 테이블에서 `JOB`이 'SALESMAN'인 첫 번째 직원을 찾습니다.
    2.  해당 직원의 `DEPTNO` 값을 가지고 `DEPT` 테이블(내부 테이블)에서 일치하는 부서 번호를 찾습니다. (이때 `DEPT.DEPTNO`에 인덱스가 있다면 매우 빠릅니다.)
    3.  일치하는 부서 정보를 찾아 결과에 추가합니다.
    4.  `JOB`이 'SALESMAN'인 다음 직원을 찾아 위 과정을 반복합니다.