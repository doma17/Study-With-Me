

# 📦 **Java 벡터(Vector) 완벽 정리**

---

## 📚 개요
`Vector`는 Java 1.0부터 제공된 **가변 길이 동적 배열**로, 내부적으로 배열을 사용합니다.  
핵심 특징은 **메서드가 동기화(synchronized)** 되어 있어 **기본적으로 스레드 안전(Thread-safe)** 하다는 점입니다.  
현대 Java에서는 일반적으로 `ArrayList`가 권장되지만, **레거시 API 호환**이나 **간단한 동기화가 필요한 경우** `Vector`가 사용됩니다.

---

## 🧩 핵심 특징
- **동적 배열**: 용량(capacity)을 자동 확장하며 요소 저장
- **스레드 안전**: 대부분의 메서드가 `synchronized`
- **성능**: 동기화 오버헤드로 단일 스레드 성능은 `ArrayList`보다 **느린 편**
- **레거시**: 컬렉션 프레임워크 도입 이전부터 존재한 **레거시 클래스**

---

## 🧮 크기와 용량 (size vs capacity)
- **size**: 현재 저장된 요소 수
- **capacity**: 내부 배열의 실제 길이(수용 가능한 최대 요소 수)
- 확장 정책: 용량이 가득 차면 **기존 용량의 2배**(JDK 구현에 따라 다를 수 있음)로 확장하거나, 생성자에서 지정한 **capacityIncrement**만큼 증가

```java
Vector<Integer> v = new Vector<>(2, 3); // 초기 용량 2, 늘릴 때마다 +3
v.add(10); // size=1, capacity=2
v.add(20); // size=2, capacity=2
v.add(30); // size=3, capacity=5 (2 + 3)
System.out.println("size=" + v.size() + ", capacity=" + v.capacity());
```

---

## ⚙️ 주요 메서드
| 메서드 | 설명 |
|---|---|
| `add(E e)` | 요소 추가 (끝에 삽입) |
| `add(int index, E e)` | 인덱스 위치에 요소 삽입 |
| `get(int index)` | 요소 읽기 |
| `set(int index, E e)` | 요소 대체 |
| `remove(int index)` / `remove(Object o)` | 제거 |
| `size()` / `isEmpty()` | 크기/비어있음 확인 |
| `capacity()` | 현재 용량 반환 (Vector 고유) |
| `clear()` | 모두 삭제 |
| `contains(Object o)` / `indexOf(Object o)` | 포함 여부/인덱스 |
| `firstElement()` / `lastElement()` | 첫/마지막 요소 반환 |

> `capacity()`는 `Vector` 전용 API로, `ArrayList`에는 없습니다.

---

## 💡 기본 사용 예제
```java
import java.util.Vector;

public class VectorBasic {
    public static void main(String[] args) {
        Vector<String> v = new Vector<>();
        v.add("A");
        v.add("B");
        v.add(1, "X"); // 중간 삽입
        System.out.println(v); // [A, X, B]

        v.remove("X");
        System.out.println(v.get(1)); // B
        System.out.println("size=" + v.size() + ", capacity=" + v.capacity());
    }
}
```

---

## 🔐 스레드 안전성 (Synchronized) & 대안
- `Vector`의 메서드는 **모두 동기화**되어 있어, 복수 스레드가 동시에 접근해도 안전합니다.
- 단, **반복(iteration)** 자체는 외부에서 동기화를 추가하는 편이 안전합니다.

```java
Vector<Integer> v = new Vector<>();
synchronized (v) {
    for (Integer x : v) {
        // 안전한 순회
    }
}
```

### 대안
- **단일 스레드/일반적 사용**: `ArrayList` 권장
- **읽기 많은 멀티스레드**: `CopyOnWriteArrayList`
- **맵/셋 동기화**: `Collections.synchronizedList(new ArrayList<>())` 등 래퍼 사용

---

## 🧠 Vector vs ArrayList vs CopyOnWriteArrayList

| 구분 | Vector | ArrayList | CopyOnWriteArrayList |
|---|---|---|---|
| 내부 구조 | 배열 | 배열 | 배열(복사 기반) |
| 동기화 | 기본 제공(메서드 단위) | 없음(래퍼 필요) | 내장(쓰기 시 전체 복사) |
| 단일 스레드 성능 | 느림 | 빠름 | 느림(쓰기), 빠름(읽기) |
| 사용 추천 | 레거시 호환/간단한 동기화 | 대부분의 경우 | 읽기 위주 멀티스레드 |

---

## 🧱 성능 & 확장 정책 주의사항
- 빈번한 **중간 삽입/삭제**는 내부 배열 이동으로 **O(n)** 비용 → `LinkedList` 고려
- 용량 확장 시 **배열 복사 비용** 발생 → 예상 용량이 크다면 **초기 capacity 설정** 권장
- 동기화 오버헤드로 단일 스레드에서는 `ArrayList`가 유리

---

## 🧾 순회 방법
```java
Vector<String> v = new Vector<>();
v.add("A"); v.add("B"); v.add("C");

// 1) 향상된 for
for (String s : v) System.out.println(s);

// 2) 인덱스 기반
for (int i = 0; i < v.size(); i++) System.out.println(v.get(i));

// 3) Enumeration (레거시 스타일)
for (var e = v.elements(); e.hasMoreElements(); ) {
    System.out.println(e.nextElement());
}
```

---

## ⚠️ 흔한 실수
- `Vector`가 있다고 해서 **무조건 멀티스레드 안전**한 코드를 보장하지는 않습니다.  
  반복 중 동시에 변경하면 `ConcurrentModificationException`은 덜하지만 **논리적 경쟁 조건**은 여전할 수 있습니다.
- `capacity()`를 남용해 용량만 보고 설계하면, 실제 **메모리 사용량**과 맞지 않을 수 있습니다.

---

## 📌 정리
> **`Vector`는 동기화를 기본 제공하는 레거시 동적 배열**입니다.  
> 현대 Java에서는 대부분 `ArrayList` 또는 `CopyOnWriteArrayList`로 대체하지만, **간단한 동기화가 필요하거나 레거시 API 호환**이 필요한 경우 유용합니다.