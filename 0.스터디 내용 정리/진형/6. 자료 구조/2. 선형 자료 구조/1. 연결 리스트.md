

# 🧩 **Java ArrayList & LinkedList 완벽 정리**

## 📚 개요
Java의 `ArrayList`와 `LinkedList`는 모두 **List 인터페이스**를 구현한 선형 자료구조입니다.  
하지만 **내부 구조와 접근 방식**이 다르기 때문에 상황에 따라 **성능 차이가 매우 큽니다.**

---

## 🧱 ArrayList

### ✅ 개념
- **배열 기반 리스트**
- 내부적으로 **동적 배열(Dynamic Array)** 을 사용하여 데이터를 관리합니다.
- 인덱스를 이용한 **임의 접근(Random Access)** 이 가능하며 빠릅니다.

### 🧩 특징
- 초기 용량(capacity)을 초과하면 **새 배열을 생성 후 복사(copy)** 가 일어납니다.
- 중간 삽입 및 삭제 시 요소를 **이동시켜야 하므로 O(n)** 시간이 걸립니다.
- 메모리가 **연속적**이라 **캐시 효율성(Cache locality)** 이 좋습니다.

### ⚙️ 주요 연산 복잡도
| 연산 | 평균 | 최악 | 설명 |
|------|-------|-------|------|
| 접근 (get, set) | O(1) | O(1) | 인덱스로 직접 접근 가능 |
| 삽입 (add) | O(1)* | O(n) | *맨 뒤 추가 시, 공간 부족 시 O(n) 복사 발생 |
| 중간 삽입/삭제 | O(n) | O(n) | 요소 이동 필요 |
| 탐색 (contains) | O(n) | O(n) | 순차 탐색 |
| 공간 복잡도 | O(n) | O(n) | 내부 배열 크기 유지 |

### 💡 사용 예시
```java
import java.util.*;

public class ArrayListExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Cherry");

        System.out.println(list.get(1)); // Banana

        list.remove("Banana");
        System.out.println(list); // [Apple, Cherry]
    }
}
```

---

## 🔗 LinkedList

### ✅ 개념
- **노드(Node)** 들이 **포인터로 연결된 구조**.
- 각 노드는 데이터와 이전/다음 노드의 주소(`prev`, `next`)를 저장합니다.
- Java의 `LinkedList`는 **이중 연결 리스트(Doubly Linked List)** 로 구현되어 있습니다.

### 🧩 특징
- 삽입/삭제는 빠르지만, 임의 접근은 느립니다.
- 메모리가 **불연속적**으로 할당되며, **포인터 저장 공간 오버헤드**가 있습니다.
- 내부적으로 `Node` 클래스가 존재하여 링크를 관리합니다.

### ⚙️ 주요 연산 복잡도
| 연산 | 평균 | 최악 | 설명 |
|------|-------|-------|------|
| 접근 (get) | O(n) | O(n) | 인덱스로 접근 시 순차 탐색 필요 |
| 삽입/삭제 (add/remove) | O(1)* | O(n) | *참조를 알고 있을 때 O(1) |
| 탐색 (contains) | O(n) | O(n) | 순차 탐색 |
| 공간 복잡도 | O(n) | O(n) | 각 노드의 prev/next 포인터로 인한 추가 공간 필요 |

### 💡 사용 예시
```java
import java.util.*;

public class LinkedListExample {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<>();
        list.add("A");
        list.add("B");
        list.addFirst("Start");
        list.addLast("End");

        System.out.println(list); // [Start, A, B, End]

        list.removeFirst();
        list.removeLast();
        System.out.println(list); // [A, B]
    }
}
```

---

## ⚖️ ArrayList vs LinkedList 비교 요약

| 구분 | ArrayList | LinkedList |
|------|------------|-------------|
| 내부 구조 | 동적 배열 | 이중 연결 리스트 |
| 접근 속도 | 빠름 (O(1)) | 느림 (O(n)) |
| 삽입/삭제 속도 | 느림 (O(n)) | 빠름 (O(1)) (참조 알고 있을 때) |
| 메모리 효율 | 효율적 | 비효율적 (노드 포인터 저장) |
| 랜덤 접근 | 가능 | 불가능 |
| 순차 접근 | 느림 | 빠름 |
| 캐시 효율성 | 높음 | 낮음 |
| 쓰레드 안전성 | X (동기화 필요) | X (동기화 필요) |

---

## 🧠 선택 기준

| 상황 | 추천 자료구조 | 이유 |
|------|----------------|------|
| 인덱스로 빠르게 접근해야 할 때 | **ArrayList** | 배열 기반, O(1) 접근 |
| 중간 삽입/삭제가 잦을 때 | **LinkedList** | 노드 연결만 갱신 |
| 메모리 절약이 필요할 때 | **ArrayList** | 연속된 메모리, 포인터 불필요 |
| 순차적으로 데이터를 처리할 때 | **LinkedList** | 노드 순회 효율적 |
| 큐/덱 자료구조로 활용할 때 | **LinkedList** | `addFirst`, `addLast` 지원 |

---

## ⚡ 성능 비교 실험 (참고용)
```java
import java.util.*;

public class ListPerformanceTest {
    public static void main(String[] args) {
        int n = 100000;
        List<Integer> arrayList = new ArrayList<>();
        List<Integer> linkedList = new LinkedList<>();

        // 삽입 테스트
        long start = System.nanoTime();
        for (int i = 0; i < n; i++) arrayList.add(i);
        long end = System.nanoTime();
        System.out.println("ArrayList add: " + (end - start) / 1e6 + "ms");

        start = System.nanoTime();
        for (int i = 0; i < n; i++) linkedList.add(i);
        end = System.nanoTime();
        System.out.println("LinkedList add: " + (end - start) / 1e6 + "ms");

        // 중간 삭제 테스트
        start = System.nanoTime();
        for (int i = 0; i < 1000; i++) arrayList.remove(n/2);
        end = System.nanoTime();
        System.out.println("ArrayList remove: " + (end - start) / 1e6 + "ms");

        start = System.nanoTime();
        for (int i = 0; i < 1000; i++) linkedList.remove(n/2);
        end = System.nanoTime();
        System.out.println("LinkedList remove: " + (end - start) / 1e6 + "ms");
    }
}
```
> 💡 보통 `ArrayList`가 **랜덤 접근에**, `LinkedList`가 **빈번한 삽입/삭제에** 강점을 가집니다.

---

## 📌 결론

| 상황 | 더 적합한 자료구조 | 핵심 이유 |
|------|-------------------|-----------|
| 읽기/탐색 위주 | **ArrayList** | O(1) 접근 |
| 삽입/삭제 위주 | **LinkedList** | 포인터 연결 구조 |
| 메모리 절약 | **ArrayList** | 연속 메모리 구조 |
| 큐, 덱 구현 | **LinkedList** | 양방향 링크 구조 |

> ✅ 정리하자면  
> - `ArrayList` → **읽기 중심, 탐색용**  
> - `LinkedList` → **수정 중심, 삽입/삭제 많은 경우**