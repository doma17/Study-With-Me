# 🧩 동적 계획법 (Dynamic Programming) — 1로 만들기

---

## 🎯 문제 개요

정수 `N`이 주어지면, 다음 세 연산 중 하나를 사용해 `1`로 만들는 **최소 연산 횟수**를 구하시오.

* `N`이 3으로 나누어 떨어지면 3으로 나는다.
* `N`이 2로 나누어 떨어지면 2로 나는다.
* 1을 빼내는다.

---

## 🧠 핵심 아이디어

이 문제는 결국 “**최소 연산 횟수**”를 구하는 문제이다.
즉, `N`에서 시작해 `1`로 가는 모든 경우 중 **가장 짧은 경로**를 찾아야 한다.

이 과정을 통해 **완전탑산에서 복사연수 과정을 거칠 때까지의 사고 발전**을 보여준다.

---

# 1️⃣ 완전탑산 (Brute Force)

### 💡 사고 흐름

모든 가능한 연산을 **uc804부 시도**해보는 방식.
즉, “3으로 나눌까?”, “2으로 나눌까?”, “1을 빼내보자?” 세 가지 선택을 **모두 탑산**한다.
아무런 최적화가 없기 때문에 **uc911복 계산이 폭발적으로 발생**한다.

---

### 💻 코드

```java
static int solve(int n) {
    if (n == 1) return 0;  // 기저 조건
    int res = Integer.MAX_VALUE;

    if (n % 3 == 0) res = Math.min(res, solve(n / 3) + 1);
    if (n % 2 == 0) res = Math.min(res, solve(n / 2) + 1);
    res = Math.min(res, solve(n - 1) + 1);

    return res;
}
```

---

### 🧩 예시 (n = 6)

```
solve(6)
 ├─ solve(2) (6/3)
 ├─ solve(3) (6/2)
 └─ solve(5) (6-1)
```

`solve(3)` 안에서도 다시 `solve(2)`와 `solve(1)`이 호출되며
**uc911복 계산이 매우 많다.**

---

### ⚙️ 특징

| 항목     | 내용                |
| ------ | ----------------- |
| 접근 방식  | 모든 경우 탑산          |
| 중복 계산  | 매우 많음             |
| 시간 복잡도 | O(2ⁿ)             |
| 장점     | 사고 출발점 (문제 구성 감각) |
| 단점     | 너무 느림             |

---

# 2️⃣ 반환 버전 (Recursive Thinking)

### 💡 사고 전환

“각 경우의 최소값을 **ubc18환**받아서, 그 중 **uac00장 작은 값**을 선택해면 되지 않을까?”

즉, `solve(n)`은

> “n을 1로 만들기 위한 최소 연산 횟수”
> 를 반환하는 함수로 정의한다.

---

### 💻 코드

```java
int solve(int n) {
    if (n == 1) return 0;

    int res = solve(n - 1) + 1;  // 1을 빼는 연산
    if (n % 2 == 0) res = Math.min(res, solve(n / 2) + 1);
    if (n % 3 == 0) res = Math.min(res, solve(n / 3) + 1);

    return res;
}
```

---

### ⚙️ 특징

* 완전탑산보다는 의미가 명확해졌다.
* 각 단계의 결과(`solve(n)`) 을 “**uc815의된 의미를 가진 반환값**”으로 사용.
* 역식 **uc911복 호출**이 많지만,
  이때 **uc810화식(Recurrence Relation)** 을 돌출할 수 있다.

---

### 🥮 점화식

```
f(n) = min(f(n-1), f(n/2), f(n/3)) + 1
```

---

### 📈 중간 사고 발전

| 단계     | 사고 내용               |
| ------ | ------------------- |
| 완전탑산   | “일단 다 해보다.”         |
| 반환형 재귀 | “각 결과를 반환받아 비교해보자.” |

---

# 3️⃣ 메모이제이션 (Top-Down DP)

### 💡 사고 전환

“이미 구한 `f(k)`는 다시 계산하지 말고 **uc800장**하자!”
즉, 계산 결과를 **uce90싱(Memoization)** 해두면 같은 계산을 반복하지 않는다.

---

### 💻 코드

```java
static int[] memo = new int[1000001];

static int solve(int n) {
    if (n == 1) return 0;
    if (memo[n] != 0) return memo[n];  // 이미 계산된 경우 재활용

    int res = solve(n - 1) + 1;
    if (n % 2 == 0) res = Math.min(res, solve(n / 2) + 1);
    if (n % 3 == 0) res = Math.min(res, solve(n / 3) + 1);

    return memo[n] = res;  // 계산 결과 저장
}
```

---

### ⚙️ 특징

| 항목     | 내용                |
| ------ | ----------------- |
| 접근 방식  | Top-Down (재귀)     |
| 중복 계산  | 제거됨               |
| 시간 복잡도 | O(n)              |
| 공간 복잡도 | O(n)              |
| 장점     | 재귀 구조 유지하면서 효율 증가 |
| 단점     | 스택 깊이(재귀 한계) 존재   |

---

### 🧠 작동 흐름 예시 (n = 10)

```
solve(10)
 ├─ solve(9)
 │   ├─ solve(8)
 │   ├─ solve(3)
 │   └─ ...
 ├─ solve(5)
 └─ solve(9) ← 이미 memo에 있음 → 재활용
```

> 이제 같은 `solve(9)`는 단 한번만 계산됨 👏

---

# 4️⃣ DP 테이블 (Bottom-Up DP)

### 💡 사고 전환

“재귀로 위에서 내려오는 대신,
작은 수(1)부터 큰 수(N)까지 **uc21c서대로 계산**하자!”

---

### 💻 코드

```java
static int dp(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 0;

    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + 1;  // 기본 연산 (1 빼기)
        if (i % 2 == 0) dp[i] = Math.min(dp[i], dp[i / 2] + 1);
        if (i % 3 == 0) dp[i] = Math.min(dp[i], dp[i / 3] + 1);
    }

    return dp[n];
}
```

---

### ⚙️ 특징

| 항목     | 내용              |
| ------ | --------------- |
| 접근 방식  | Bottom-Up (반복문) |
| 중복 계산  | 없음              |
| 시간 복잡도 |                 |
