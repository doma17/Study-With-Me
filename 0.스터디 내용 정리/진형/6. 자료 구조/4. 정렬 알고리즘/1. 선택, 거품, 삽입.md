# 🔢 **기본 정렬 알고리즘 정리 (선택, 거품, 삽입 정렬)**

## 📘 **개요**

정렬(Sorting)은 데이터(배열, 리스트 등)를 **특정 기준(오름차순/내림차순)** 에 따라 순서대로 배치하는 알고리즘입니다.
이 문서에서는 가장 기초적인 정렬 알고리즘인 **선택 정렬(Selection Sort)**, **거품 정렬(Bubble Sort)**, **삽입 정렬(Insertion Sort)** 을 정리합니다.

---

# 🧩 **1️⃣ 선택 정렬 (Selection Sort)**

## 💡 개념

* 매 단계에서 **가장 작은(또는 큰)** 데이터를 선택하여 **앞쪽으로 이동**시키는 방식.
* 배열을 **부분적으로 정렬**하면서 진행함.

## ⚙️ 과정 요약

1. 배열에서 가장 작은 원소를 찾는다.
2. 현재 위치의 원소와 교환한다.
3. 다음 인덱스로 이동하며 위 과정을 반복한다.

## 🧠 특징

| 구분     | 내용            |
| ------ | ------------- |
| 시간 복잡도 | O(n²)         |
| 공간 복잡도 | O(1)          |
| 안정성    | ❌ 불안정 정렬      |
| 정렬 방식  | 비교 기반, 제자리 정렬 |

## 💻 예제 (Java)

```java
public class SelectionSort {
    public static void selectionSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            int minIdx = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIdx]) {
                    minIdx = j;
                }
            }
            int temp = arr[minIdx];
            arr[minIdx] = arr[i];
            arr[i] = temp;
        }
    }
}
```

---

# 💨 **2️⃣ 거품 정렬 (Bubble Sort)**

## 💡 개념

* 인접한 두 원소를 비교하여 **큰 값을 뒤로 이동**시키는 방식.
* 한 번의 패스(Pass)가 끝날 때마다 가장 큰 원소가 맨 뒤로 ‘거품처럼’ 올라감.

## ⚙️ 과정 요약

1. 배열의 첫 번째 원소부터 인접한 두 원소를 비교.
2. 순서가 잘못되어 있으면 교환.
3. 전체를 한 바퀴 돌면 가장 큰 원소가 맨 끝으로 이동.
4. 위 과정을 (n-1)번 반복.

## 🧠 특징

| 구분     | 내용                    |
| ------ | --------------------- |
| 시간 복잡도 | O(n²) (최적화 시 O(n) 가능) |
| 공간 복잡도 | O(1)                  |
| 안정성    | ✅ 안정 정렬               |
| 정렬 방식  | 비교 기반, 제자리 정렬         |

## 💻 예제 (Java)

```java
public class BubbleSort {
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            boolean swapped = false;
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                }
            }
            if (!swapped) break; // 이미 정렬된 경우 종료
        }
    }
}
```

---

# 🧮 **3️⃣ 삽입 정렬 (Insertion Sort)**

## 💡 개념

* **앞쪽 부분은 항상 정렬된 상태**로 유지하면서, 새 원소를 **적절한 위치에 삽입**하는 방식.
* 카드 놀이에서 손에 든 카드를 정렬하는 방식과 유사함.

## ⚙️ 과정 요약

1. 두 번째 원소부터 시작.
2. 현재 원소를 이전 원소들과 비교하여 알맞은 위치에 삽입.
3. 모든 원소가 정렬될 때까지 반복.

## 🧠 특징

| 구분     | 내용                     |
| ------ | ---------------------- |
| 시간 복잡도 | O(n²) (거의 정렬된 경우 O(n)) |
| 공간 복잡도 | O(1)                   |
| 안정성    | ✅ 안정 정렬                |
| 정렬 방식  | 비교 기반, 제자리 정렬          |

## 💻 예제 (Java)

```java
public class InsertionSort {
    public static void insertionSort(int[] arr) {
        int n = arr.length;
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            int j = i - 1;

            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
    }
}
```

---

# ⚖️ **비교 요약표**

| 정렬 알고리즘 | 시간 복잡도 | 공간 복잡도 | 안정성 | 특징                  |
| ------- | ------ | ------ | --- | ------------------- |
| 선택 정렬   | O(n²)  | O(1)   | ❌   | 단순하지만 느림, 교환 횟수 적음  |
| 거품 정렬   | O(n²)  | O(1)   | ✅   | 구현 간단, 이미 정렬된 경우 빠름 |
| 삽입 정렬   | O(n²)  | O(1)   | ✅   | 거의 정렬된 데이터에 효율적     |

---

# 💡 **요약**

> 세 알고리즘 모두 구현이 간단하고 학습용으로 적합하지만, **시간 복잡도 O(n²)** 로 인해 대규모 데이터에는 비효율적입니다.
> 그러나 삽입 정렬은 **거의 정렬된 배열에서 효율적**이며, 실제 정렬 알고리즘(예: Tim Sort)의 일부로 활용됩니다.
