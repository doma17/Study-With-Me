# ⚙️ **고급 정렬 알고리즘 정리 (병합, 퀵, 힙 정렬)**

## 📘 **개요**

고급 정렬 알고리즘은 기본 정렬(O(n²))보다 빠른 **O(n log n)** 시간 복잡도를 가지며, 대규모 데이터 처리에 효율적입니다.
이 문서에서는 대표적인 세 가지 알고리즘인 **병합 정렬(Merge Sort)**, **퀵 정렬(Quick Sort)**, **힙 정렬(Heap Sort)** 을 정리합니다.

---

# 🧩 **1️⃣ 병합 정렬 (Merge Sort)**

## 💡 개념

* **분할 정복(Divide and Conquer)** 전략을 사용하는 알고리즘.
* 배열을 반으로 나누고, 각각을 정렬한 뒤 **합병(merge)** 하여 하나의 정렬된 배열로 만듭니다.

## ⚙️ 과정 요약

1. 배열을 반으로 나눈다.
2. 각 부분 배열을 재귀적으로 정렬한다.
3. 두 배열을 합병하면서 정렬된 배열을 만든다.

## 🧠 특징

| 구분     | 내용              |
| ------ | --------------- |
| 시간 복잡도 | O(n log n)      |
| 공간 복잡도 | O(n) (임시 배열 필요) |
| 안정성    | ✅ 안정 정렬         |
| 정렬 방식  | 분할 정복 기반        |

## 💻 예제 (Java)

```java
public class MergeSort {
    public static void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = (left + right) / 2;
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }

    private static void merge(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;

        int[] L = new int[n1];
        int[] R = new int[n2];

        for (int i = 0; i < n1; i++) L[i] = arr[left + i];
        for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];

        int i = 0, j = 0, k = left;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) arr[k++] = L[i++];
            else arr[k++] = R[j++];
        }

        while (i < n1) arr[k++] = L[i++];
        while (j < n2) arr[k++] = R[j++];
    }
}
```

---

# ⚡ **2️⃣ 퀵 정렬 (Quick Sort)**

## 💡 개념

* 병합 정렬과 마찬가지로 **분할 정복(Divide and Conquer)** 기반.
* **피벗(Pivot)** 을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 분할 후 재귀 정렬.

## ⚙️ 과정 요약

1. 배열에서 피벗을 선택.
2. 피벗보다 작은 원소는 왼쪽, 큰 원소는 오른쪽으로 분할.
3. 각 부분 배열을 재귀적으로 정렬.

## 🧠 특징

| 구분        | 내용                   |
| --------- | -------------------- |
| 평균 시간 복잡도 | O(n log n)           |
| 최악 시간 복잡도 | O(n²) (피벗 선택이 나쁠 경우) |
| 공간 복잡도    | O(log n) (재귀 스택)     |
| 안정성       | ❌ 불안정 정렬             |
| 정렬 방식     | 분할 정복 기반             |

## 💻 예제 (Java)

```java
public class QuickSort {
    public static void quickSort(int[] arr, int left, int right) {
        if (left < right) {
            int pivotIndex = partition(arr, left, right);
            quickSort(arr, left, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, right);
        }
    }

    private static int partition(int[] arr, int left, int right) {
        int pivot = arr[right];
        int i = left - 1;
        for (int j = left; j < right; j++) {
            if (arr[j] <= pivot) {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        int temp = arr[i + 1];
        arr[i + 1] = arr[right];
        arr[right] = temp;
        return i + 1;
    }
}
```

---

# 🏗️ **3️⃣ 힙 정렬 (Heap Sort)**

## 💡 개념

* **완전 이진 트리(Complete Binary Tree)** 구조를 이용한 정렬 알고리즘.
* 힙(Heap)의 성질을 이용해 최대값(또는 최소값)을 루트로 올려 정렬.

## ⚙️ 과정 요약

1. 배열을 **최대 힙(Max Heap)** 으로 구성.
2. 루트(최대값)와 마지막 원소를 교환.
3. 힙 크기를 줄이고 다시 힙 구조 유지 (heapify).
4. 모든 요소가 정렬될 때까지 반복.

## 🧠 특징

| 구분     | 내용               |
| ------ | ---------------- |
| 시간 복잡도 | O(n log n)       |
| 공간 복잡도 | O(1)             |
| 안정성    | ❌ 불안정 정렬         |
| 정렬 방식  | 선택 기반, 힙 자료구조 이용 |

## 💻 예제 (Java)

```java
public class HeapSort {
    public static void heapSort(int[] arr) {
        int n = arr.length;

        // 최대 힙 구성
        for (int i = n / 2 - 1; i >= 0; i--)
            heapify(arr, n, i);

        // 하나씩 원소 추출
        for (int i = n - 1; i > 0; i--) {
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;

            heapify(arr, i, 0);
        }
    }

    private static void heapify(int[] arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;

        if (left < n && arr[left] > arr[largest]) largest = left;
        if (right < n && arr[right] > arr[largest]) largest = right;

        if (largest != i) {
            int swap = arr[i];
            arr[i] = arr[largest];
            arr[largest] = swap;

            heapify(arr, n, largest);
        }
    }
}
```

---

# ⚖️ **비교 요약표**

| 정렬 알고리즘 | 시간 복잡도                | 공간 복잡도   | 안정성 | 주요 특징                   |
| ------- | --------------------- | -------- | --- | ----------------------- |
| 병합 정렬   | O(n log n)            | O(n)     | ✅   | 안정 정렬, 분할 정복 기반         |
| 퀵 정렬    | O(n log n) (최악 O(n²)) | O(log n) | ❌   | 평균적으로 가장 빠름             |
| 힙 정렬    | O(n log n)            | O(1)     | ❌   | 추가 메모리 불필요, 완전 이진 트리 기반 |

---

# 💡 **요약**

> 세 알고리즘 모두 **O(n log n)** 의 효율을 가지며, 실제 응용에서도 널리 사용됩니다.
>
> * **병합 정렬:** 안정적이며 외부 정렬에 적합
> * **퀵 정렬:** 평균적으로 가장 빠름 (메모리 효율 좋음)
> * **힙 정렬:** 추가 메모리 사용이 없고, 일정한 시간 복잡도를 보장
