# 🏗️ **Java 힙(Heap) 완벽 정리**

---

## 📚 개요

힙(Heap)은 완전 이진 트리(Complete Binary Tree) 형태를 가지는 특수한 자료구조입니다.  
완전 이진 트리는 마지막 레벨을 제외한 모든 레벨이 꽉 차 있고, 마지막 레벨은 왼쪽부터 차례로 채워진 트리를 말합니다.

힙은 크게 두 가지 유형으로 나뉩니다.

- **최소 힙(Min Heap)**: 부모 노드가 자식 노드보다 작거나 같은 값을 갖는 힙. 루트 노드가 가장 작은 값을 가집니다.
- **최대 힙(Max Heap)**: 부모 노드가 자식 노드보다 크거나 같은 값을 갖는 힙. 루트 노드가 가장 큰 값을 가집니다.

힙은 우선순위 큐(Priority Queue) 구현에 주로 사용되며, 삽입과 삭제가 효율적입니다.

---

## 🧩 힙의 종류

### 최소 힙 (Min Heap)

```
        10
       /  \
     20    30
    /  \
  40    50
```

- 루트가 가장 작고, 자식은 부모보다 크거나 같음.
- 최솟값을 빠르게 찾을 수 있음.

### 최대 힙 (Max Heap)

```
        50
       /  \
     30    20
    /  \
  10    5
```

- 루트가 가장 크고, 자식은 부모보다 작거나 같음.
- 최댓값을 빠르게 찾을 수 있음.

---

## ⚙️ 힙의 주요 연산

| 연산       | 설명                         | 시간 복잡도 |
|------------|------------------------------|-------------|
| 삽입 (insert) | 새로운 원소를 힙에 추가          | O(log n)    |
| 삭제 (delete) | 루트 노드(최대값/최소값) 삭제     | O(log n)    |
| 조회 (peek)  | 루트 노드 값 조회               | O(1)        |

- 삽입과 삭제 시 힙 속성을 유지하기 위해 재정렬이 필요합니다.

---

## 💡 Java에서의 PriorityQueue

Java에서는 `PriorityQueue` 클래스를 통해 힙을 쉽게 사용할 수 있습니다.  
기본적으로 최소 힙으로 동작하며, 삽입과 삭제가 자동으로 힙 속성을 유지합니다.

```java
import java.util.PriorityQueue;

public class MinHeapExample {
    public static void main(String[] args) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();

        minHeap.add(30);
        minHeap.add(10);
        minHeap.add(20);

        System.out.println("최소값: " + minHeap.peek()); // 10

        while (!minHeap.isEmpty()) {
            System.out.println(minHeap.poll());
        }
        // 출력 순서: 10, 20, 30
    }
}
```

---

## 🧮 최대 힙 구현

`PriorityQueue`는 기본적으로 최소 힙이지만, `Collections.reverseOrder()`를 이용해 최대 힙으로 사용할 수 있습니다.

```java
import java.util.Collections;
import java.util.PriorityQueue;

public class MaxHeapExample {
    public static void main(String[] args) {
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());

        maxHeap.add(30);
        maxHeap.add(10);
        maxHeap.add(20);

        System.out.println("최대값: " + maxHeap.peek()); // 30

        while (!maxHeap.isEmpty()) {
            System.out.println(maxHeap.poll());
        }
        // 출력 순서: 30, 20, 10
    }
}
```

---

## 🧠 내부 동작 원리

힙에서 삽입과 삭제 시 힙 속성을 유지하기 위해 다음과 같은 재정렬 작업이 이루어집니다.

- **상향 재정렬 (Up-Heap, Bubble-Up)**:  
  새로 삽입한 노드가 부모보다 크거나 작을 경우, 부모와 위치를 바꾸며 루트 방향으로 올라갑니다.

- **하향 재정렬 (Down-Heap, Bubble-Down)**:  
  루트 노드를 삭제한 후 마지막 노드를 루트로 올리고, 자식 노드들과 비교하며 적절한 위치로 내려갑니다.

이 과정을 통해 힙의 특성을 항상 유지합니다.

---

## ⚠️ 주의사항

- 힙은 완전 이진 트리 형태를 갖지만, **전체적으로 정렬된 자료구조는 아닙니다**.  
  즉, 중간 노드들끼리는 정렬이 보장되지 않습니다.
- `PriorityQueue`는 기본적으로 **자연 순서(natural ordering)** 또는 생성 시 제공된 `Comparator`에 따라 정렬됩니다.
- 힙은 우선순위 큐 구현에 적합하지만, 전체 데이터를 정렬해야 할 때는 힙 정렬(Heap Sort)을 사용합니다.

---

## 🧱 힙 정렬(Heap Sort)

힙 정렬은 힙 자료구조를 이용해 데이터를 정렬하는 알고리즘입니다.

1. 배열을 힙 구조로 변환 (Build Heap)
2. 루트 노드(최대값 또는 최솟값)를 배열의 끝과 교환
3. 힙 크기를 줄이고, 다시 힙 속성을 유지하도록 재정렬
4. 2~3 과정을 반복하여 정렬 완료

```java
public class HeapSort {
    public static void heapify(int[] arr, int n, int i) {
        int largest = i; 
        int left = 2 * i + 1; 
        int right = 2 * i + 2; 

        if (left < n && arr[left] > arr[largest])
            largest = left;

        if (right < n && arr[right] > arr[largest])
            largest = right;

        if (largest != i) {
            int temp = arr[i];
            arr[i] = arr[largest];
            arr[largest] = temp;

            heapify(arr, n, largest);
        }
    }

    public static void heapSort(int[] arr) {
        int n = arr.length;

        // Build max heap
        for (int i = n / 2 - 1; i >= 0; i--)
            heapify(arr, n, i);

        // One by one extract elements
        for (int i = n - 1; i > 0; i--) {
            // Move current root to end
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;

            // call max heapify on the reduced heap
            heapify(arr, i, 0);
        }
    }
}
```

---

## 📌 정리

힙은 완전 이진 트리 기반의 우선순위 큐 자료구조로, 최소값 또는 최대값을 빠르게 찾고 삽입·삭제 연산을 효율적으로 수행할 수 있습니다. Java에서는 `PriorityQueue` 클래스로 쉽게 활용 가능합니다.
