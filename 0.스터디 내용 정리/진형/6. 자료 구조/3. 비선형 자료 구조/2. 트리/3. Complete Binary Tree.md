

# 🌲 **완전 이진 트리 (Complete Binary Tree) 완벽 정리**

---

## 📚 개요

**완전 이진 트리(Complete Binary Tree)**란,  
모든 레벨(마지막 레벨 제외)이 노드로 가득 차 있으며,  
마지막 레벨은 왼쪽부터 연속적으로 노드가 채워진 이진 트리입니다.

즉, 트리의 구조가 아래와 같이 "왼쪽부터 빈틈없이" 채워져야 완전 이진 트리입니다.

---

## 🧩 특징

| 구분               | 완전 이진 트리                                              | 포화 이진 트리                  |
|--------------------|-----------------------------------------------------------|-------------------------------|
| 채워지는 방식      | 마지막 레벨만 예외, 왼쪽부터 빈틈없이 채움                    | 모든 레벨이 완전히 채워짐         |
| 노드 개수 규칙     | n개의 노드, 높이 h이면 ⌊log₂n⌋ ≤ h < log₂(n+1)             | n = 2^h - 1                    |
| 배열 인덱스 표현   | 배열 인덱스로 손쉽게 표현 가능 (힙 구조 등)                   | 동일                            |
| 자식/부모 인덱스   | 부모: i, 왼쪽 자식: 2i, 오른쪽 자식: 2i+1 (1-based 인덱스)    | 동일                            |

---

## 💡 예시 트리

아래는 노드 1~6으로 구성된 완전 이진 트리의 예시입니다.

```
        1
      /   \
     2     3
    / \   /
   4   5 6
```
> 7번 자리가 비어있지만, 마지막 레벨은 왼쪽부터 채워졌으므로 완전 이진 트리입니다.

---

## ⚙️ 배열 기반 표현

완전 이진 트리는 배열로 쉽게 표현할 수 있습니다.

### 인덱스 규칙 (1-based)
- 부모 노드 인덱스: `i`
- 왼쪽 자식: `2i`
- 오른쪽 자식: `2i + 1`

### 예시
| 인덱스 | 값  | 부모 | 왼쪽 자식 | 오른쪽 자식 |
|--------|-----|------|-----------|-------------|
| 1      |  1  |  -   | 2         | 3           |
| 2      |  2  | 1    | 4         | 5           |
| 3      |  3  | 1    | 6         | 7           |
| 4      |  4  | 2    | -         | -           |
| 5      |  5  | 2    | -         | -           |
| 6      |  6  | 3    | -         | -           |
| 7      | (X) | 3    | -         | -           |

### 예시 코드 (배열 기반 완전 이진 트리)
```java
// 1-based 인덱스 사용 예시
int[] tree = new int[8]; // 1~7번 인덱스 사용
tree[1] = 1;
tree[2] = 2;
tree[3] = 3;
tree[4] = 4;
tree[5] = 5;
tree[6] = 6;
// tree[7]은 비어 있음
```

---

## 🧮 Java 예시 코드

아래는 완전 이진 트리의 삽입과 순회를 배열로 구현한 간단한 예시입니다.

```java
public class CompleteBinaryTree {
    int[] tree;
    int size;

    public CompleteBinaryTree(int capacity) {
        tree = new int[capacity + 1]; // 1-based 인덱스
        size = 0;
    }

    // 삽입: 마지막에 추가
    public void insert(int value) {
        if (size + 1 >= tree.length) return;
        tree[++size] = value;
    }

    // 중위 순회
    public void inorder(int idx) {
        if (idx > size) return;
        inorder(idx * 2);       // 왼쪽 자식
        System.out.print(tree[idx] + " ");
        inorder(idx * 2 + 1);   // 오른쪽 자식
    }

    public static void main(String[] args) {
        CompleteBinaryTree cbt = new CompleteBinaryTree(7);
        for (int i = 1; i <= 6; i++) cbt.insert(i);
        cbt.inorder(1); // 출력: 4 2 5 1 6 3
    }
}
```

---

## 🧠 완전 이진 트리 vs 포화 이진 트리 비교

| 구분           | 완전 이진 트리                                            | 포화 이진 트리             |
|----------------|---------------------------------------------------------|--------------------------|
| 정의           | 마지막 레벨 제외, 모든 레벨이 노드로 가득 참. 마지막 레벨은 왼쪽부터 채움 | 모든 레벨이 노드로 가득 참  |
| 노드 개수      | 2^h-1 ≤ n ≤ 2^h-1 (h: 높이)                              | n = 2^h - 1              |
| 예시           | 6개 노드 트리, 마지막 레벨 일부만 채워짐                  | 7개 노드 트리, 모두 채워짐 |
| 사용 예        | 힙(Heap), 우선순위 큐 등                                  | 트리 균형성 분석 등        |

---

## ⚠️ 주의사항

- **배열 인덱스 계산 실수 주의:**  
  1-based, 0-based 인덱스를 혼동하지 않도록 주의해야 합니다.
- **Null 노드 처리:**  
  마지막 레벨의 오른쪽 부분이 비어있는 경우, 해당 인덱스는 값이 없을 수 있으므로  
  순회 및 연산 시 인덱스 범위 체크가 필요합니다.
- **포화 이진 트리와 혼동 주의:**  
  완전 이진 트리는 마지막 레벨이 꼭 다 채워져 있을 필요는 없습니다.

---

## 📌 정리

> **완전 이진 트리란, 마지막 레벨을 제외한 모든 레벨이 가득 차 있고, 마지막 레벨은 왼쪽부터 연속적으로 노드가 채워진 이진 트리입니다.**