

# 🌿 **Java 이진 탐색 트리 (Binary Search Tree, BST) 완벽 정리**

---

## 📚 개요

**이진 탐색 트리(BST, Binary Search Tree)**는 각 노드가 최대 두 개의 자식 노드를 가지며, 다음과 같은 규칙을 만족하는 트리 자료구조입니다.

- **왼쪽 서브트리의 모든 노드 값 < 루트 노드 값 < 오른쪽 서브트리의 모든 노드 값**
- 이 규칙은 모든 서브트리에 재귀적으로 적용됩니다.

BST는 효율적인 탐색, 삽입, 삭제 연산을 지원하여 다양한 알고리즘과 데이터베이스 인덱싱 등에 널리 사용됩니다.

---

## 🧩 특징

| 특징                | 설명                                                         |
|---------------------|-------------------------------------------------------------|
| **정렬 상태**        | 항상 정렬된 상태 유지 (중위 순회 시 오름차순)                |
| **탐색/삽입/삭제**   | 평균 O(log n), 최악 O(n)                                    |
| **중복 허용**        | 구현에 따라 다름 (일반적으로 허용하지 않음)                  |
| **최대 자식 수**     | 각 노드는 최대 2개의 자식                                   |
| **동적 크기**        | 데이터 추가/삭제에 따라 동적으로 크기 변화                  |

---

## 💡 BST의 규칙 시각화

아래는 BST의 기본 구조를 텍스트로 표현한 예시입니다.

```
        [8]
       /   \
     [3]   [10]
     / \      \
   [1] [6]    [14]
        / \    /
      [4] [7][13]
```

- **왼쪽 자식**은 항상 **부모보다 작고**
- **오른쪽 자식**은 항상 **부모보다 큽니다.**

---

## ⚙️ Java 구현 예제

### 1. Node 클래스 정의
```java
class Node {
    int key;
    Node left, right;

    public Node(int item) {
        key = item;
        left = right = null;
    }
}
```

### 2. 삽입 (insert)
```java
class BST {
    Node root;

    public BST() {
        root = null;
    }

    void insert(int key) {
        root = insertRec(root, key);
    }

    Node insertRec(Node root, int key) {
        if (root == null) {
            root = new Node(key);
            return root;
        }
        if (key < root.key)
            root.left = insertRec(root.left, key);
        else if (key > root.key)
            root.right = insertRec(root.right, key);
        // 중복은 무시
        return root;
    }
}
```

### 3. 탐색 (search)
```java
boolean search(Node root, int key) {
    if (root == null)
        return false;
    if (root.key == key)
        return true;
    if (key < root.key)
        return search(root.left, key);
    else
        return search(root.right, key);
}
```

### 4. 중위 순회 (Inorder Traversal)
```java
void inorder(Node root) {
    if (root != null) {
        inorder(root.left);
        System.out.print(root.key + " ");
        inorder(root.right);
    }
}
```

---

## 🧮 삭제 연산(delete) 예시

BST에서 노드 삭제는 아래 세 가지 경우로 나뉩니다.

### 1. **삭제할 노드가 리프(자식 없음)**
- 그냥 해당 노드를 삭제하면 됩니다.

### 2. **삭제할 노드가 자식이 1개**
- 자식 노드를 부모와 연결한 뒤 삭제합니다.

### 3. **삭제할 노드가 자식이 2개**
- 오른쪽 서브트리의 최소값(또는 왼쪽 서브트리의 최대값)으로 대체한 후, 해당 노드를 삭제합니다.

#### 삭제 코드 예시
```java
Node delete(Node root, int key) {
    if (root == null) return root;
    if (key < root.key)
        root.left = delete(root.left, key);
    else if (key > root.key)
        root.right = delete(root.right, key);
    else {
        // 1. 리프 노드 or 2. 자식 1개
        if (root.left == null)
            return root.right;
        else if (root.right == null)
            return root.left;
        // 3. 자식 2개: 오른쪽 서브트리의 최소값 찾기
        root.key = minValue(root.right);
        root.right = delete(root.right, root.key);
    }
    return root;
}

int minValue(Node root) {
    int minv = root.key;
    while (root.left != null) {
        minv = root.left.key;
        root = root.left;
    }
    return minv;
}
```

---

## 🧠 BST의 시간 복잡도

| 연산      | 최선/평균 (O) | 최악 (O)   |
|-----------|--------------|------------|
| 탐색      | log n        | n          |
| 삽입      | log n        | n          |
| 삭제      | log n        | n          |

> **노트**: 트리가 균형 잡혀 있을 때(log n), 편향되면(최악) 선형 시간(n)이 걸릴 수 있습니다.

---

## ⚠️ 주의사항

- **편향 트리(Skewed Tree)**: 데이터가 정렬된 순서로 삽입되면 한쪽으로 치우쳐 리스트와 동일하게 되어 성능이 O(n)까지 저하될 수 있습니다.
- **균형 유지 필요성**: 효율적인 연산을 위해 트리의 균형을 맞추는 것이 중요합니다.

---

## 🌳 균형 트리와의 관계

| 트리 종류    | 균형 유지 방식            | 시간 복잡도 (탐색/삽입/삭제) |
|--------------|--------------------------|-----------------------------|
| BST          | X                        | O(n) ~ O(log n)             |
| AVL Tree     | 높이 균형 엄격히 유지     | O(log n)                    |
| Red-Black Tree | 느슨한 균형(색상 규칙)   | O(log n)                    |

- **AVL 트리**: 모든 노드의 왼쪽/오른쪽 서브트리 높이 차이가 최대 1
- **Red-Black 트리**: 노드에 색상을 부여해 느슨하게 균형 유지 (자바 TreeMap 등에서 사용)

---

## 📌 정리

> **이진 탐색 트리(BST)는 효율적인 탐색, 삽입, 삭제가 가능한 정렬된 트리 구조로, 트리의 균형이 성능에 큰 영향을 미치므로 실제 사용 시 균형 트리(AVL, Red-Black 등)도 함께 고려해야 합니다.**
