# 🌲 **AVL 트리 (AVL Tree) 자료구조 정리**

## 📘 개념

**AVL 트리**는 **이진 탐색 트리(Binary Search Tree, BST)** 의 한 종류로, 삽입이나 삭제 이후에도 **항상 균형(balance)** 을 유지하도록 설계된 **자기 균형 이진 탐색 트리(Self-Balancing BST)** 입니다.

> 1962년 러시아의 수학자 **Adelson-Velsky** 와 **Landis** 가 고안했으며, 두 사람의 이름 머리글자를 따서 **AVL 트리**라고 부릅니다.

---

## 🧩 특징

* 모든 노드에 대해 **왼쪽 서브트리와 오른쪽 서브트리의 높이 차이(= 균형 인수, balance factor)** 가 **-1, 0, 1** 중 하나만 허용됩니다.
* 이 조건이 깨지면 **회전(Rotation)** 을 통해 트리를 자동으로 균형 상태로 복구합니다.

```
Balance Factor = height(left subtree) - height(right subtree)
```

---

## ⚙️ 주요 연산

| 연산          | 설명                           | 시간 복잡도   |
| ----------- | ---------------------------- | -------- |
| 삽입 (Insert) | 새 노드를 삽입하고 균형을 유지하기 위해 회전 수행 | O(log N) |
| 삭제 (Delete) | 노드 삭제 후 균형 재조정               | O(log N) |
| 탐색 (Search) | 이진 탐색 트리와 동일                 | O(log N) |

---

## 🔁 회전 (Rotation) 종류

AVL 트리의 균형이 깨졌을 때, **회전(Rotation)** 을 통해 균형을 맞춥니다.

| 유형        | 설명                  | 조정 방법                  |
| --------- | ------------------- | ---------------------- |
| **LL 회전** | 왼쪽 자식의 왼쪽 부분이 무거움   | 오른쪽 회전(Right Rotation) |
| **RR 회전** | 오른쪽 자식의 오른쪽 부분이 무거움 | 왼쪽 회전(Left Rotation)   |
| **LR 회전** | 왼쪽 자식의 오른쪽 부분이 무거움  | 왼쪽 회전 후 오른쪽 회전         |
| **RL 회전** | 오른쪽 자식의 왼쪽 부분이 무거움  | 오른쪽 회전 후 왼쪽 회전         |

```
LL 회전 예시:

    3                      2
   /                      / \
  2        →            1   3
 /
1
```

---

## 💻 **자바 예제 코드**

```java
class Node {
    int key, height;
    Node left, right;

    Node(int d) {
        key = d;
        height = 1;
    }
}

public class AVLTree {

    Node root;

    // 노드 높이 반환
    int height(Node N) {
        if (N == null) return 0;
        return N.height;
    }

    // 균형 인수 계산
    int getBalance(Node N) {
        if (N == null) return 0;
        return height(N.left) - height(N.right);
    }

    // 오른쪽 회전
    Node rightRotate(Node y) {
        Node x = y.left;
        Node T2 = x.right;

        x.right = y;
        y.left = T2;

        y.height = Math.max(height(y.left), height(y.right)) + 1;
        x.height = Math.max(height(x.left), height(x.right)) + 1;

        return x;
    }

    // 왼쪽 회전
    Node leftRotate(Node x) {
        Node y = x.right;
        Node T2 = y.left;

        y.left = x;
        x.right = T2;

        x.height = Math.max(height(x.left), height(x.right)) + 1;
        y.height = Math.max(height(y.left), height(y.right)) + 1;

        return y;
    }

    // 삽입
    Node insert(Node node, int key) {
        if (node == null)
            return new Node(key);

        if (key < node.key)
            node.left = insert(node.left, key);
        else if (key > node.key)
            node.right = insert(node.right, key);
        else
            return node;

        node.height = 1 + Math.max(height(node.left), height(node.right));

        int balance = getBalance(node);

        // LL
        if (balance > 1 && key < node.left.key)
            return rightRotate(node);

        // RR
        if (balance < -1 && key > node.right.key)
            return leftRotate(node);

        // LR
        if (balance > 1 && key > node.left.key) {
            node.left = leftRotate(node.left);
            return rightRotate(node);
        }

        // RL
        if (balance < -1 && key < node.right.key) {
            node.right = rightRotate(node.right);
            return leftRotate(node);
        }

        return node;
    }

    // 중위 순회 출력
    void inOrder(Node node) {
        if (node != null) {
            inOrder(node.left);
            System.out.print(node.key + " ");
            inOrder(node.right);
        }
    }

    public static void main(String[] args) {
        AVLTree tree = new AVLTree();

        tree.root = tree.insert(tree.root, 10);
        tree.root = tree.insert(tree.root, 20);
        tree.root = tree.insert(tree.root, 30);
        tree.root = tree.insert(tree.root, 40);
        tree.root = tree.insert(tree.root, 50);
        tree.root = tree.insert(tree.root, 25);

        System.out.println("중위 순회 결과:");
        tree.inOrder(tree.root);
    }
}
```

---

## 🧠 **AVL 트리의 장단점**

| 장점                          | 단점                            |
| --------------------------- | ----------------------------- |
| 항상 균형을 유지하므로 O(log N) 시간 보장 | 회전 연산으로 인해 삽입/삭제 시 추가 오버헤드 발생 |
| 탐색 속도가 빠르고 안정적              | 구현이 복잡함                       |

---

## 💡 **요약**

> **AVL 트리(AVL Tree)** 는 **항상 균형을 유지하는 이진 탐색 트리**로,
> 탐색·삽입·삭제 모두 O(log N) 성능을 보장합니다.
