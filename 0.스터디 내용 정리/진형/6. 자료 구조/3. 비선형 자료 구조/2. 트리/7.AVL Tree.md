# ğŸŒ² **AVL íŠ¸ë¦¬ (AVL Tree) ìë£Œêµ¬ì¡° ì •ë¦¬**

## ğŸ“˜ ê°œë…

**AVL íŠ¸ë¦¬**ëŠ” **ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬(Binary Search Tree, BST)** ì˜ í•œ ì¢…ë¥˜ë¡œ, ì‚½ì…ì´ë‚˜ ì‚­ì œ ì´í›„ì—ë„ **í•­ìƒ ê· í˜•(balance)** ì„ ìœ ì§€í•˜ë„ë¡ ì„¤ê³„ëœ **ìê¸° ê· í˜• ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬(Self-Balancing BST)** ì…ë‹ˆë‹¤.

> 1962ë…„ ëŸ¬ì‹œì•„ì˜ ìˆ˜í•™ì **Adelson-Velsky** ì™€ **Landis** ê°€ ê³ ì•ˆí–ˆìœ¼ë©°, ë‘ ì‚¬ëŒì˜ ì´ë¦„ ë¨¸ë¦¬ê¸€ìë¥¼ ë”°ì„œ **AVL íŠ¸ë¦¬**ë¼ê³  ë¶€ë¦…ë‹ˆë‹¤.

---

## ğŸ§© íŠ¹ì§•

* ëª¨ë“  ë…¸ë“œì— ëŒ€í•´ **ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ì™€ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ì˜ ë†’ì´ ì°¨ì´(= ê· í˜• ì¸ìˆ˜, balance factor)** ê°€ **-1, 0, 1** ì¤‘ í•˜ë‚˜ë§Œ í—ˆìš©ë©ë‹ˆë‹¤.
* ì´ ì¡°ê±´ì´ ê¹¨ì§€ë©´ **íšŒì „(Rotation)** ì„ í†µí•´ íŠ¸ë¦¬ë¥¼ ìë™ìœ¼ë¡œ ê· í˜• ìƒíƒœë¡œ ë³µêµ¬í•©ë‹ˆë‹¤.

```
Balance Factor = height(left subtree) - height(right subtree)
```

---

## âš™ï¸ ì£¼ìš” ì—°ì‚°

| ì—°ì‚°          | ì„¤ëª…                           | ì‹œê°„ ë³µì¡ë„   |
| ----------- | ---------------------------- | -------- |
| ì‚½ì… (Insert) | ìƒˆ ë…¸ë“œë¥¼ ì‚½ì…í•˜ê³  ê· í˜•ì„ ìœ ì§€í•˜ê¸° ìœ„í•´ íšŒì „ ìˆ˜í–‰ | O(log N) |
| ì‚­ì œ (Delete) | ë…¸ë“œ ì‚­ì œ í›„ ê· í˜• ì¬ì¡°ì •               | O(log N) |
| íƒìƒ‰ (Search) | ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì™€ ë™ì¼                 | O(log N) |

---

## ğŸ” íšŒì „ (Rotation) ì¢…ë¥˜

AVL íŠ¸ë¦¬ì˜ ê· í˜•ì´ ê¹¨ì¡Œì„ ë•Œ, **íšŒì „(Rotation)** ì„ í†µí•´ ê· í˜•ì„ ë§ì¶¥ë‹ˆë‹¤.

| ìœ í˜•        | ì„¤ëª…                  | ì¡°ì • ë°©ë²•                  |
| --------- | ------------------- | ---------------------- |
| **LL íšŒì „** | ì™¼ìª½ ìì‹ì˜ ì™¼ìª½ ë¶€ë¶„ì´ ë¬´ê±°ì›€   | ì˜¤ë¥¸ìª½ íšŒì „(Right Rotation) |
| **RR íšŒì „** | ì˜¤ë¥¸ìª½ ìì‹ì˜ ì˜¤ë¥¸ìª½ ë¶€ë¶„ì´ ë¬´ê±°ì›€ | ì™¼ìª½ íšŒì „(Left Rotation)   |
| **LR íšŒì „** | ì™¼ìª½ ìì‹ì˜ ì˜¤ë¥¸ìª½ ë¶€ë¶„ì´ ë¬´ê±°ì›€  | ì™¼ìª½ íšŒì „ í›„ ì˜¤ë¥¸ìª½ íšŒì „         |
| **RL íšŒì „** | ì˜¤ë¥¸ìª½ ìì‹ì˜ ì™¼ìª½ ë¶€ë¶„ì´ ë¬´ê±°ì›€  | ì˜¤ë¥¸ìª½ íšŒì „ í›„ ì™¼ìª½ íšŒì „         |

```
LL íšŒì „ ì˜ˆì‹œ:

    3                      2
   /                      / \
  2        â†’            1   3
 /
1
```

---

## ğŸ’» **ìë°” ì˜ˆì œ ì½”ë“œ**

```java
class Node {
    int key, height;
    Node left, right;

    Node(int d) {
        key = d;
        height = 1;
    }
}

public class AVLTree {

    Node root;

    // ë…¸ë“œ ë†’ì´ ë°˜í™˜
    int height(Node N) {
        if (N == null) return 0;
        return N.height;
    }

    // ê· í˜• ì¸ìˆ˜ ê³„ì‚°
    int getBalance(Node N) {
        if (N == null) return 0;
        return height(N.left) - height(N.right);
    }

    // ì˜¤ë¥¸ìª½ íšŒì „
    Node rightRotate(Node y) {
        Node x = y.left;
        Node T2 = x.right;

        x.right = y;
        y.left = T2;

        y.height = Math.max(height(y.left), height(y.right)) + 1;
        x.height = Math.max(height(x.left), height(x.right)) + 1;

        return x;
    }

    // ì™¼ìª½ íšŒì „
    Node leftRotate(Node x) {
        Node y = x.right;
        Node T2 = y.left;

        y.left = x;
        x.right = T2;

        x.height = Math.max(height(x.left), height(x.right)) + 1;
        y.height = Math.max(height(y.left), height(y.right)) + 1;

        return y;
    }

    // ì‚½ì…
    Node insert(Node node, int key) {
        if (node == null)
            return new Node(key);

        if (key < node.key)
            node.left = insert(node.left, key);
        else if (key > node.key)
            node.right = insert(node.right, key);
        else
            return node;

        node.height = 1 + Math.max(height(node.left), height(node.right));

        int balance = getBalance(node);

        // LL
        if (balance > 1 && key < node.left.key)
            return rightRotate(node);

        // RR
        if (balance < -1 && key > node.right.key)
            return leftRotate(node);

        // LR
        if (balance > 1 && key > node.left.key) {
            node.left = leftRotate(node.left);
            return rightRotate(node);
        }

        // RL
        if (balance < -1 && key < node.right.key) {
            node.right = rightRotate(node.right);
            return leftRotate(node);
        }

        return node;
    }

    // ì¤‘ìœ„ ìˆœíšŒ ì¶œë ¥
    void inOrder(Node node) {
        if (node != null) {
            inOrder(node.left);
            System.out.print(node.key + " ");
            inOrder(node.right);
        }
    }

    public static void main(String[] args) {
        AVLTree tree = new AVLTree();

        tree.root = tree.insert(tree.root, 10);
        tree.root = tree.insert(tree.root, 20);
        tree.root = tree.insert(tree.root, 30);
        tree.root = tree.insert(tree.root, 40);
        tree.root = tree.insert(tree.root, 50);
        tree.root = tree.insert(tree.root, 25);

        System.out.println("ì¤‘ìœ„ ìˆœíšŒ ê²°ê³¼:");
        tree.inOrder(tree.root);
    }
}
```

---

## ğŸ§  **AVL íŠ¸ë¦¬ì˜ ì¥ë‹¨ì **

| ì¥ì                           | ë‹¨ì                             |
| --------------------------- | ----------------------------- |
| í•­ìƒ ê· í˜•ì„ ìœ ì§€í•˜ë¯€ë¡œ O(log N) ì‹œê°„ ë³´ì¥ | íšŒì „ ì—°ì‚°ìœ¼ë¡œ ì¸í•´ ì‚½ì…/ì‚­ì œ ì‹œ ì¶”ê°€ ì˜¤ë²„í—¤ë“œ ë°œìƒ |
| íƒìƒ‰ ì†ë„ê°€ ë¹ ë¥´ê³  ì•ˆì •ì               | êµ¬í˜„ì´ ë³µì¡í•¨                       |

---

## ğŸ’¡ **ìš”ì•½**

> **AVL íŠ¸ë¦¬(AVL Tree)** ëŠ” **í•­ìƒ ê· í˜•ì„ ìœ ì§€í•˜ëŠ” ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬**ë¡œ,
> íƒìƒ‰Â·ì‚½ì…Â·ì‚­ì œ ëª¨ë‘ O(log N) ì„±ëŠ¥ì„ ë³´ì¥í•©ë‹ˆë‹¤.
