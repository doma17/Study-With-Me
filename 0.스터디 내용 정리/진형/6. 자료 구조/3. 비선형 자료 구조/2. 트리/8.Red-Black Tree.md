# 🔴⚫ **Red-Black Tree (레드-블랙 트리) 자료구조 정리**

# 📘 **개념**

**Red-Black Tree(레드-블랙 트리)** 는 **이진 탐색 트리(Binary Search Tree, BST)** 의 한 종류로, 삽입과 삭제가 일어나도 **트리의 균형을 효율적으로 유지**하도록 설계된 **자기 균형 이진 탐색 트리(Self-Balancing BST)** 입니다.

> 이름은 각 노드가 빨간색(Red) 또는 검정색(Black)으로 표시되는 데서 유래했습니다.

---

# 🧩 **특징**

Red-Black Tree는 각 노드에 색상 속성이 추가되어 있으며, 다음 **5가지 속성**을 만족해야 합니다:

1. 각 노드는 **빨강(Red)** 또는 **검정(Black)** 색을 가진다.
2. 루트 노드는 항상 **검정(Black)** 이다.
3. 모든 리프(NIL, null)는 **검정(Black)** 으로 간주한다.
4. 빨강 노드의 자식은 항상 **검정(Black)** 이어야 한다. (즉, 연속된 빨강 노드는 없다)
5. 임의의 노드에서 리프까지의 **모든 경로에는 동일한 수의 검정 노드**가 존재해야 한다.

이 규칙 덕분에 트리의 높이가 거의 일정하게 유지되어, **탐색/삽입/삭제 연산을 O(log N)** 시간에 수행할 수 있습니다.

---

# ⚙️ **주요 연산 및 복잡도**

| 연산              | 설명                                     | 시간 복잡도   |
| --------------- | -------------------------------------- | -------- |
| **탐색 (Search)** | 이진 탐색 트리와 동일하게 수행                      | O(log N) |
| **삽입 (Insert)** | 새 노드 추가 후 색상 규칙을 만족시키기 위해 회전 및 색 변경 수행 | O(log N) |
| **삭제 (Delete)** | 노드 삭제 후 균형 및 색상 규칙 복원                  | O(log N) |

---

# 🔁 **균형 유지 (회전 및 색상 변경)**

삽입이나 삭제 시 규칙이 깨지면, **회전(Rotation)** 과 **색상(Color Flip)** 으로 트리를 복구합니다.

## 예시 상황

* **Case 1:** 부모가 빨강이고, 삼촌이 빨강 → 부모와 삼촌을 검정으로, 조부모를 빨강으로 변경
* **Case 2:** 부모가 빨강이고, 삼촌이 검정 → LL, RR, LR, RL 형태에 따라 회전 수행

## 회전 예시 (LL Case)

```
    10(B)                10(B)
   /                        \
  5(R)        →            7(R)
   \                      / \
    7(R)                5(B) 8(B)
```

---

# 💻 **자바 예제 코드 (삽입 중심)**

```java
enum Color { RED, BLACK }

class Node {
    int data;
    Color color;
    Node left, right, parent;

    Node(int data) {
        this.data = data;
        this.color = Color.RED; // 새 노드는 항상 빨강으로 삽입
        left = right = parent = null;
    }
}

public class RedBlackTree {
    private Node root;

    // 좌회전
    private void rotateLeft(Node x) {
        Node y = x.right;
        x.right = y.left;
        if (y.left != null) y.left.parent = x;
        y.parent = x.parent;
        if (x.parent == null) root = y;
        else if (x == x.parent.left) x.parent.left = y;
        else x.parent.right = y;
        y.left = x;
        x.parent = y;
    }

    // 우회전
    private void rotateRight(Node y) {
        Node x = y.left;
        y.left = x.right;
        if (x.right != null) x.right.parent = y;
        x.parent = y.parent;
        if (y.parent == null) root = x;
        else if (y == y.parent.left) y.parent.left = x;
        else y.parent.right = x;
        x.right = y;
        y.parent = x;
    }

    // 삽입
    public void insert(int data) {
        Node newNode = new Node(data);
        root = bstInsert(root, newNode);
        fixViolation(newNode);
    }

    // 기본 BST 삽입
    private Node bstInsert(Node root, Node node) {
        if (root == null) return node;
        if (node.data < root.data) {
            root.left = bstInsert(root.left, node);
            root.left.parent = root;
        } else if (node.data > root.data) {
            root.right = bstInsert(root.right, node);
            root.right.parent = root;
        }
        return root;
    }

    // 규칙 위반 수정
    private void fixViolation(Node node) {
        Node parent = null, grandParent = null;
        while (node != root && node.color == Color.RED && node.parent.color == Color.RED) {
            parent = node.parent;
            grandParent = parent.parent;

            if (parent == grandParent.left) {
                Node uncle = grandParent.right;
                if (uncle != null && uncle.color == Color.RED) { // Case 1
                    grandParent.color = Color.RED;
                    parent.color = Color.BLACK;
                    uncle.color = Color.BLACK;
                    node = grandParent;
                } else { // Case 2
                    if (node == parent.right) {
                        rotateLeft(parent);
                        node = parent;
                        parent = node.parent;
                    }
                    rotateRight(grandParent);
                    Color temp = parent.color;
                    parent.color = grandParent.color;
                    grandParent.color = temp;
                    node = parent;
                }
            } else {
                Node uncle = grandParent.left;
                if (uncle != null && uncle.color == Color.RED) {
                    grandParent.color = Color.RED;
                    parent.color = Color.BLACK;
                    uncle.color = Color.BLACK;
                    node = grandParent;
                } else {
                    if (node == parent.left) {
                        rotateRight(parent);
                        node = parent;
                        parent = node.parent;
                    }
                    rotateLeft(grandParent);
                    Color temp = parent.color;
                    parent.color = grandParent.color;
                    grandParent.color = temp;
                    node = parent;
                }
            }
        }
        root.color = Color.BLACK;
    }

    // 중위 순회 출력
    public void inorder(Node root) {
        if (root != null) {
            inorder(root.left);
            System.out.print(root.data + "(" + root.color + ") ");
            inorder(root.right);
        }
    }

    public void printTree() {
        inorder(root);
        System.out.println();
    }

    public static void main(String[] args) {
        RedBlackTree tree = new RedBlackTree();
        int[] values = {10, 20, 30, 15, 25, 5, 1};
        for (int val : values) tree.insert(val);
        tree.printTree();
    }
}
```

---

# 🧠 **장단점**

| 장점                                    | 단점                   |
| ------------------------------------- | -------------------- |
| 항상 거의 균형을 유지하여 탐색, 삽입, 삭제 모두 O(log N) | 구현이 복잡하고 코드가 길어짐     |
| AVL 트리보다 회전이 적어 삽입/삭제가 빠름             | 탐색은 AVL보다 약간 느릴 수 있음 |

---

# 💡 **요약**

> **Red-Black Tree** 는 트리의 균형을 색상 규칙으로 효율적으로 유지하여,
> **삽입/삭제 시 오버헤드가 적고 안정적인 성능을 제공하는 BST 변형**입니다.
