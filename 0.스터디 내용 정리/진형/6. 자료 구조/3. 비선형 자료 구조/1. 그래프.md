# 🕸️ **Java 그래프(Graph) 완벽 정리**

---

## 📚 개요

그래프(Graph)는 여러 개의 정점(Vertex)과 정점들을 연결하는 간선(Edge)으로 구성된 자료구조입니다.  
- **정점(Vertex)**: 그래프를 구성하는 노드 또는 점  
- **간선(Edge)**: 정점과 정점을 연결하는 선  
- **가중치(Weight)**: 간선에 부여된 값으로, 거리나 비용 등을 나타냄  
- **방향(Directed)**: 간선이 한쪽 방향으로만 연결되는 경우  
- **무방향(Undirected)**: 간선이 양방향으로 연결되는 경우  

그래프는 현실 세계의 복잡한 관계를 표현하는 데 매우 유용하며, 네트워크, 지도, 소셜 미디어 등 다양한 분야에 활용됩니다.

---

## 🧩 그래프의 종류

1. **무방향 그래프 (Undirected Graph)**  
   간선에 방향이 없으며, 정점 A와 B가 연결되면 A→B, B→A 모두 연결된 상태입니다.  
   ```
   A --- B
   |     |
   C --- D
   ```

2. **방향 그래프 (Directed Graph)**  
   간선에 방향이 있으며, 정점 A에서 B로 가는 간선이 있어도 B에서 A로 가는 간선이 없을 수 있습니다.  
   ```
   A → B
   ↑    ↓
   D ← C
   ```

3. **가중치 그래프 (Weighted Graph)**  
   간선에 가중치가 부여된 그래프입니다.  
   ```
   A --2-- B
   |       |
   5       3
   |       |
   C --1-- D
   ```

4. **인접 그래프 (Adjacency Graph)**  
   정점 간의 연결 상태를 인접 행렬 또는 인접 리스트로 표현한 그래프입니다.

---

## ⚙️ 그래프의 표현 방식

그래프는 크게 두 가지 방식으로 표현됩니다.

### 1. 인접 행렬 (Adjacency Matrix)  
- 정점 수가 N일 때, N×N 크기의 2차원 배열 사용  
- 배열의 값으로 간선의 존재(또는 가중치)를 표시  
- 간선 존재 여부를 빠르게 확인 가능하지만, 공간 복잡도가 큼 (O(N²))  

### 2. 인접 리스트 (Adjacency List)  
- 각 정점마다 연결된 정점들을 리스트로 관리  
- 공간 효율적이며, 간선이 적은 희소 그래프에 적합  
- 탐색 시 연결된 모든 간선을 순회해야 함  

---

### Java 코드 예시

```java
// 인접 행렬 예시
int[][] adjMatrix = new int[N][N];

// 인접 리스트 예시
ArrayList<ArrayList<Integer>> adjList = new ArrayList<>();
for (int i = 0; i < N; i++) {
    adjList.add(new ArrayList<>());
}
```

---

## 💡 인접 행렬 구현

```java
public class GraphMatrix {
    private int[][] graph;
    private int size;

    public GraphMatrix(int size) {
        this.size = size;
        graph = new int[size][size];
    }

    // 간선 추가 (무방향)
    public void addEdge(int from, int to) {
        graph[from][to] = 1;
        graph[to][from] = 1;
    }

    // 그래프 출력
    public void printGraph() {
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                System.out.print(graph[i][j] + " ");
            }
            System.out.println();
        }
    }
}
```

---

## 🧮 인접 리스트 구현

```java
import java.util.ArrayList;

public class GraphList {
    private ArrayList<ArrayList<Integer>> graph;
    private int size;

    public GraphList(int size) {
        this.size = size;
        graph = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            graph.add(new ArrayList<>());
        }
    }

    // 간선 추가 (무방향)
    public void addEdge(int from, int to) {
        graph.get(from).add(to);
        graph.get(to).add(from);
    }

    // 그래프 출력
    public void printGraph() {
        for (int i = 0; i < size; i++) {
            System.out.print(i + " : ");
            for (int v : graph.get(i)) {
                System.out.print(v + " ");
            }
            System.out.println();
        }
    }
}
```

---

## 🔍 그래프 탐색 알고리즘

### BFS (너비 우선 탐색)  
- 시작 정점에서 인접한 정점을 먼저 방문  
- 큐(Queue)를 사용하여 탐색  
- 최단 경로 탐색에 유리  

```java
import java.util.*;

public void bfs(int start, ArrayList<ArrayList<Integer>> graph, boolean[] visited) {
    Queue<Integer> queue = new LinkedList<>();
    queue.offer(start);
    visited[start] = true;

    while (!queue.isEmpty()) {
        int v = queue.poll();
        System.out.print(v + " ");

        for (int next : graph.get(v)) {
            if (!visited[next]) {
                queue.offer(next);
                visited[next] = true;
            }
        }
    }
}
```

### DFS (깊이 우선 탐색)  
- 시작 정점에서 깊게 깊게 탐색  
- 재귀 또는 스택(Stack) 사용  
- 경로 존재 여부, 연결 요소 탐색에 유리  

```java
public void dfs(int v, ArrayList<ArrayList<Integer>> graph, boolean[] visited) {
    visited[v] = true;
    System.out.print(v + " ");

    for (int next : graph.get(v)) {
        if (!visited[next]) {
            dfs(next, graph, visited);
        }
    }
}
```

---

## ⚠️ 주의사항

- **무한 루프 방지**: 방문한 정점을 다시 방문하지 않도록 `visited` 배열을 반드시 사용해야 합니다.  
- **방향성 고려**: 방향 그래프에서는 간선의 방향에 따라 탐색 범위가 달라집니다.  
- **그래프의 크기와 밀도에 따라 표현 방식 선택**: 큰 그래프나 희소 그래프는 인접 리스트가 효율적입니다.  

---

## 🧠 그래프 vs 트리 비교

| 구분       | 그래프(Graph)                          | 트리(Tree)                         |
|------------|-------------------------------------|-----------------------------------|
| 구조       | 정점과 간선의 집합                   | 사이클 없는 연결 그래프            |
| 사이클     | 존재할 수 있음                      | 존재하지 않음                     |
| 방향       | 방향 그래프, 무방향 그래프 모두 가능 | 방향 트리 (루트 방향)              |
| 루트       | 루트가 없음                         | 하나의 루트 노드 존재             |
| 연결성     | 연결되지 않을 수 있음                | 모든 노드가 연결되어 있음         |
| 용도       | 네트워크, 소셜 그래프 등              | 계층 구조 표현, 파일 시스템 등     |

---

## 📌 정리

**그래프는 정점과 간선으로 구성된 복잡한 관계를 표현하는 자료구조로, 상황에 맞는 표현 방식과 탐색 알고리즘을 활용하는 것이 중요합니다.**
