# 🧮 **Java Hashtable 완벽 정리**

---

## 📚 개요

Hashtable은 Java에서 제공하는 자료구조 중 하나로, 키(key)와 값(value)을 쌍으로 저장하는 Map 인터페이스의 구현체입니다. 내부적으로 해시 함수를 이용해 데이터를 저장하고 검색하기 때문에 빠른 접근 속도를 자랑합니다. 키를 통해 값을 빠르게 찾을 수 있으며, 중복된 키는 허용하지 않습니다.

Hashtable은 Map 인터페이스를 구현하여, 키-값 쌍을 저장하고 관리하는 다양한 메서드를 제공합니다.

---

## 🧩 Hashtable의 특징

- **동기화 지원 (Synchronized)**  
  Hashtable은 메서드 단위로 동기화가 되어 있어 멀티스레드 환경에서 안전하게 사용할 수 있습니다.

- **null 키 및 null 값 불허**  
  Hashtable은 key나 value에 null을 허용하지 않습니다. null을 넣으려 하면 `NullPointerException`이 발생합니다.

- **순서 비보장**  
  저장된 데이터가 입력한 순서대로 유지되지 않습니다. 내부 해시 함수와 버킷 구조에 따라 순서가 결정됩니다.

- **레거시 클래스**  
  Hashtable은 Java 1.0부터 존재한 오래된 클래스이며, 이후에 나온 HashMap과 비교하여 동기화 등의 차이가 있습니다.

---

## ⚙️ 주요 메서드

| 메서드                | 설명                                | 반환값                         |
|---------------------|-----------------------------------|------------------------------|
| `put(K key, V value)`    | 키와 값을 저장하거나 기존 값을 덮어씀         | 이전에 저장된 값 또는 null          |
| `get(Object key)`        | 키에 해당하는 값을 반환                   | 값 또는 null                   |
| `remove(Object key)`     | 키에 해당하는 값을 삭제                   | 삭제된 값 또는 null              |
| `containsKey(Object key)`| 특정 키가 존재하는지 확인                  | boolean                      |
| `containsValue(Object value)` | 특정 값이 존재하는지 확인                  | boolean                      |
| `size()`                 | 저장된 키-값 쌍의 개수 반환                 | int                          |
| `isEmpty()`              | Hashtable이 비어있는지 확인                  | boolean                      |
| `clear()`                | 모든 키-값 쌍 삭제                       | void                         |
| `keys()`                 | 모든 키를 Enumeration으로 반환               | Enumeration<K>               |
| `elements()`             | 모든 값을 Enumeration으로 반환               | Enumeration<V>               |

---

## 💡 기본 사용 예제

```java
import java.util.Hashtable;

public class HashtableExample {
    public static void main(String[] args) {
        Hashtable<String, String> table = new Hashtable<>();

        // 데이터 추가
        table.put("apple", "사과");
        table.put("banana", "바나나");
        table.put("orange", "오렌지");

        // 데이터 검색
        String value = table.get("banana");
        System.out.println("banana: " + value);

        // 데이터 삭제
        table.remove("orange");

        // 전체 크기 출력
        System.out.println("Hashtable 크기: " + table.size());
    }
}
```

---

## 🧠 내부 동작 원리

Hashtable은 내부적으로 배열과 연결 리스트(체이닝)를 사용하여 데이터를 저장합니다.

1. **해시 함수**  
   키 객체의 `hashCode()` 메서드를 호출하여 해시 값을 구하고, 이 값을 배열 크기로 나눈 나머지로 저장할 버킷(bucket) 위치를 결정합니다.

2. **버킷(bucket)**  
   해시 값에 따라 데이터를 저장할 위치인 버킷이 결정되며, 각 버킷은 여러 개의 엔트리를 저장할 수 있습니다.

3. **충돌 처리 (체이닝)**  
   서로 다른 키가 같은 버킷에 위치할 경우, 연결 리스트로 충돌을 처리합니다. 새 엔트리는 리스트의 앞 또는 뒤에 추가됩니다.

4. **스레드 안전(Thread-safe)**  
   Hashtable의 메서드는 모두 synchronized 키워드가 붙어 있어, 여러 스레드가 동시에 접근해도 데이터 무결성을 보장합니다. 하지만 이로 인해 성능 저하가 발생할 수 있습니다.

---

## ⚠️ 주의사항

- **HashMap과의 차이점**  
  Hashtable은 동기화를 지원하지만, HashMap은 기본적으로 동기화되지 않습니다. 따라서 멀티스레드 환경에서는 Hashtable이 안전하지만, 성능은 HashMap보다 떨어집니다.

- **null 허용 여부**  
  Hashtable은 key와 value 모두 null을 허용하지 않지만, HashMap은 하나의 null 키와 여러 null 값을 허용합니다.

- **동기화 오버헤드**  
  Hashtable은 모든 메서드가 동기화되어 있어 단일 스레드 환경에서는 불필요한 오버헤드가 발생합니다.

---

## 🧾 순회 방법

Hashtable의 데이터를 순회하는 대표적인 방법은 다음과 같습니다.

### 1. `entrySet()` 이용

```java
for (var entry : table.entrySet()) {
    System.out.println(entry.getKey() + " = " + entry.getValue());
}
```

### 2. `keySet()` 이용

```java
for (var key : table.keySet()) {
    System.out.println(key + " = " + table.get(key));
}
```

### 3. `elements()` 이용 (Enumeration 반환)

```java
Enumeration<String> elements = table.elements();
while (elements.hasMoreElements()) {
    System.out.println(elements.nextElement());
}
```

---

## 🧮 HashMap vs Hashtable 비교표

| 특징                  | Hashtable                      | HashMap                       |
|---------------------|------------------------------|------------------------------|
| 동기화                | 메서드 단위 동기화 지원               | 동기화 미지원 (필요시 별도 처리)        |
| null 키/값 허용         | 불가                            | null 키 1개, null 값 다수 허용          |
| 성능                  | 동기화로 인해 상대적으로 느림            | 동기화 없으므로 빠름                  |
| 레거시 여부             | 레거시 클래스                      | Java 1.2 이후 도입                   |
| 순서 보장              | 순서 비보장                       | 순서 비보장                       |
| Iterator 동작          | fail-safe 아님 (동기화로 안전)          | fail-fast (동시 수정 시 ConcurrentModificationException 발생) |

---

## 📌 정리

Hashtable은 동기화를 기본 제공하는 키-값 저장 자료구조로, 멀티스레드 환경에서 안전하게 사용할 수 있습니다. 하지만 null을 허용하지 않고, 동기화 오버헤드로 인해 단일 스레드 환경에서는 HashMap 사용이 권장됩니다. 내부적으로 해시 함수와 체이닝 방식을 사용하여 빠른 검색과 저장이 가능하며, 다양한 순회 방법을 지원합니다.
