# 🗺️ 최단 경로 (Shortest Path)

---

## 🎯 개념 요약

**최단 경로(Shortest Path)** 문제란, 그래프에서 두 정점 사이의 거리가 **가장 짧은 경로의 비용**을 구하는 문제이다.
가중치(Weight)가 있는 그래프에서 매우 자주 등장하며, **탐욕적(Greedy)** 또는 **동적 계획법(DP)** 기반 알고리즘으로 해결한다.

---

# 1️⃣ 최단 경로의 종류

| 유형             | 그래프 형태     | 음수 가중치 | 대표 알고리즘                  |
| -------------- | ---------- | ------ | ------------------------ |
| 단일 시작점 → 모든 정점 | 방향/무방향 그래프 | ❌      | 다익스트라 (Dijkstra)         |
| 단일 시작점 → 모든 정점 | 방향 그래프     | ✅      | 벨만–포드 (Bellman–Ford)     |
| 모든 정점 ↔ 모든 정점  | 방향 그래프     | ✅      | 플로이드–워셜 (Floyd–Warshall) |

---

# 2️⃣ 다익스트라 알고리즘 (Dijkstra)

### 💡 개념

> 하나의 시작점에서 다른 모든 정점까지의 **최단 거리**를 구한다.
> 단, **간선의 가중치가 모두 양수**일 때만 동작한다.

* 탐욕적(Greedy) 접근법 사용.
* 방문하지 않은 노드 중 **현재까지의 비용이 가장 작은 정점**을 선택.
* 선택된 정점을 기준으로 인접 노드의 비용을 갱신.

---

### 💻 코드 (Java - 우선순위 큐 기반)

```java
import java.util.*;

class Node implements Comparable<Node> {
    int idx, cost;
    Node(int idx, int cost) {
        this.idx = idx;
        this.cost = cost;
    }
    public int compareTo(Node o) {
        return this.cost - o.cost;
    }
}

public class Dijkstra {
    static final int INF = (int)1e9;
    static List<List<Node>> graph = new ArrayList<>();
    static int[] dist;

    static void dijkstra(int start) {
        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(start, 0));
        dist[start] = 0;

        while (!pq.isEmpty()) {
            Node cur = pq.poll();
            int now = cur.idx;

            if (cur.cost > dist[now]) continue;

            for (Node next : graph.get(now)) {
                int cost = dist[now] + next.cost;
                if (cost < dist[next.idx]) {
                    dist[next.idx] = cost;
                    pq.offer(new Node(next.idx, cost));
                }
            }
        }
    }
}
```

---

### 📊 작동 흐름 예시

```
시작: 1번 노드
1 → 2 (2)
1 → 3 (5)
2 → 3 (1)

1. dist[1] = 0
2. 2번(비용 2) 선택 → 3번 비용 3으로 갱신
3. 3번(비용 3) 선택 → 종료
```

결과: **1 → 2 → 3** 최단 거리 = 3

---

# 3️⃣ 벨만–포드 알고리즘 (Bellman–Ford)

### 💡 개념

> 음수 가중치가 존재하는 그래프에서도 사용 가능하다.

* 모든 간선을 **N-1번 반복적으로 완화(Relaxation)**
* 추가로 N번째 반복에서 값이 더 작아진다면 → **음수 사이클 존재**

---

### 💻 코드 (Java)

```java
class Edge {
    int from, to, cost;
    Edge(int from, int to, int cost) {
        this.from = from;
        this.to = to;
        this.cost = cost;
    }
}

static void bellmanFord(int n, int start, List<Edge> edges) {
    int[] dist = new int[n + 1];
    Arrays.fill(dist, INF);
    dist[start] = 0;

    for (int i = 0; i < n - 1; i++) {
        for (Edge e : edges) {
            if (dist[e.from] != INF && dist[e.to] > dist[e.from] + e.cost) {
                dist[e.to] = dist[e.from] + e.cost;
            }
        }
    }

    // 음수 사이클 검사
    for (Edge e : edges) {
        if (dist[e.from] != INF && dist[e.to] > dist[e.from] + e.cost) {
            System.out.println("Negative cycle detected");
            return;
        }
    }
}
```

---

# 4️⃣ 플로이드–워셜 알고리즘 (Floyd–Warshall)

### 💡 개념

> 모든 정점 간의 최단 거리를 구하는 알고리즘.
> **DP 기반 접근**이며, 3중 반복문을 사용한다.

### 💻 코드 (Java)

```java
static void floydWarshall(int n, int[][] dist) {
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (dist[i][j] > dist[i][k] + dist[k][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }
}
```

---

### ⚙️ 특징 비교

| 알고리즘    | 음수 간선 | 시간 복잡도     | 방식     | 사용 목적         |
| ------- | ----- | ---------- | ------ | ------------- |
| 다익스트라   | ❌     | O(E log V) | Greedy | 한 정점 → 모든 정점  |
| 벨만–포드   | ✅     | O(VE)      | DP     | 음수 간선 포함 그래프  |
| 플로이드–워셜 | ✅     | O(V³)      | DP     | 모든 정점 ↔ 모든 정점 |

---

# 🧭 핵심 요약

1. **다익스트라:** 빠르고 효율적이지만, 음수 간선은 불가.
2. **벨만–포드:** 느리지만 음수 간선 및 사이클 검출 가능.
3. **플로이드–워셜:** 모든 쌍 최단 거리, DP적 사고로 구현.

---

# 🧩 응용 포인트

* 다익스트라는 **네비게이션 / 경로 탐색 서비스** 등에 사용.
* 벨만–포드는 **금융 거래 그래프(환율)** 등 음수 가중치 탐지용.
* 플로이드–워셜은 **네트워크 최적화 / 경로 분석** 등에 적합.

> ✅ 핵심 사고법: “작은 경로부터 차근차근 최적화한다.”
> → 결국 모든 최단 경로 알고리즘은 **‘반복적인 거리 갱신(Relaxation)’** 에 기반한다.
