# ğŸ’° ìµœì†Œ ë¹„ìš© ì•Œê³ ë¦¬ì¦˜ (Minimum Cost Algorithms)

---

## ğŸ¯ ê°œë… ìš”ì•½

**ìµœì†Œ ë¹„ìš©(Minimum Cost)** ì•Œê³ ë¦¬ì¦˜ì€ ê·¸ë˜í”„ì—ì„œ ëª¨ë“  ì •ì ì„ ì—°ê²°í•˜ëŠ” ë° í•„ìš”í•œ **ê°„ì„ ë“¤ì˜ ì´ ë¹„ìš©ì´ ìµœì†Œ**ê°€ ë˜ë„ë¡ í•˜ëŠ” ë°©ë²•ì„ ë§í•œë‹¤.
ì¦‰, ê·¸ë˜í”„ ë‚´ì—ì„œ **ì‚¬ì´í´ì´ ì—†ê³  ëª¨ë“  ë…¸ë“œê°€ ì—°ê²°ëœ ìµœì†Œ ë¹„ìš© íŠ¸ë¦¬**ë¥¼ ë§Œë“œëŠ” ë¬¸ì œì´ë©°, ì´ë¥¼ **ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬(MST, Minimum Spanning Tree)** ë¼ê³  ë¶€ë¥¸ë‹¤.

---

# 1ï¸âƒ£ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ (MST, Minimum Spanning Tree)

### ğŸ’¡ ì •ì˜

* ê·¸ë˜í”„ì˜ ëª¨ë“  ì •ì ì„ ì—°ê²°í•˜ëŠ” ë¶€ë¶„ ê·¸ë˜í”„ ì¤‘, **ê°„ì„ ì˜ í•©ì´ ìµœì†Œì¸ íŠ¸ë¦¬**.
* **ì‚¬ì´í´ì´ ì—†ì–´ì•¼ í•¨ (íŠ¸ë¦¬ êµ¬ì¡°)**.
* **ëª¨ë“  ì •ì ì´ ì—°ê²°ë˜ì–´ì•¼ í•¨ (Spanning).**

ëŒ€í‘œ ì•Œê³ ë¦¬ì¦˜: **Kruskal(í¬ë£¨ìŠ¤ì¹¼)**, **Prim(í”„ë¦¼)**

---

# 2ï¸âƒ£ í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ (Kruskalâ€™s Algorithm)

### ğŸ’¡ ê°œë…

> ê°„ì„ ì„ **ê°€ì¤‘ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬**í•œ ë’¤,
> **ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šê²Œ** í•˜ë‚˜ì”© ì„ íƒí•˜ì—¬ MSTë¥¼ ë§Œë“ ë‹¤.

### âš™ï¸ í•µì‹¬ ì•„ì´ë””ì–´

* ê°„ì„  ì¤‘ì‹¬(Greedy) ì ‘ê·¼ë²•
* **Union-Find**(ì„œë¡œì†Œ ì§‘í•©)ë¥¼ ì´ìš©í•´ ì‚¬ì´í´ ì—¬ë¶€ë¥¼ íŒë‹¨

---

### ğŸ’» ì½”ë“œ (Java)

```java
import java.util.*;

class Edge implements Comparable<Edge> {
    int from, to, cost;
    Edge(int from, int to, int cost) {
        this.from = from;
        this.to = to;
        this.cost = cost;
    }
    public int compareTo(Edge o) {
        return this.cost - o.cost;
    }
}

public class Kruskal {
    static int[] parent;

    static int find(int x) {
        if (parent[x] == x) return x;
        return parent[x] = find(parent[x]);
    }

    static void union(int a, int b) {
        a = find(a);
        b = find(b);
        if (a != b) parent[b] = a;
    }

    static int kruskal(int v, List<Edge> edges) {
        Collections.sort(edges);
        parent = new int[v + 1];
        for (int i = 1; i <= v; i++) parent[i] = i;

        int total = 0;
        for (Edge e : edges) {
            if (find(e.from) != find(e.to)) {
                union(e.from, e.to);
                total += e.cost;
            }
        }
        return total;
    }
}
```

---

### ğŸ§© ì˜ˆì‹œ íë¦„

```
ê°„ì„  ë¦¬ìŠ¤íŠ¸ (ë¹„ìš© ê¸°ì¤€ ì •ë ¬)
(1-2: 3), (2-3: 4), (1-3: 5)

1. (1-2) ì„ íƒ â†’ ì—°ê²°ë¨
2. (2-3) ì„ íƒ â†’ ì—°ê²°ë¨ (ëª¨ë“  ì •ì  ì—°ê²° ì™„ë£Œ)
3. (1-3) ì œì™¸ (ì‚¬ì´í´ ë°œìƒ)
ê²°ê³¼: MST ë¹„ìš© = 7
```

---

### âš™ï¸ íŠ¹ì§•

| í•­ëª©     | ë‚´ìš©                        |
| ------ | ------------------------- |
| ì ‘ê·¼ ë°©ì‹  | Greedy (ê°„ì„  ì¤‘ì‹¬)            |
| ìë£Œêµ¬ì¡°   | Union-Find (Disjoint Set) |
| ì‹œê°„ ë³µì¡ë„ | O(E log E)                |
| ì¥ì      | êµ¬í˜„ ë‹¨ìˆœ, ê°„ì„  ìœ„ì£¼ íƒìƒ‰           |
| ë‹¨ì      | ê°„ì„ ì´ ë§¤ìš° ë§ì„ ê²½ìš° ë¹„íš¨ìœ¨ì          |

---

# 3ï¸âƒ£ í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ (Primâ€™s Algorithm)

### ğŸ’¡ ê°œë…

> **ì‹œì‘ ì •ì  í•˜ë‚˜ì—ì„œ ì¶œë°œ**,
> ì¸ì ‘í•œ ê°„ì„  ì¤‘ **ê°€ì¥ ë¹„ìš©ì´ ì‘ì€ ê°„ì„ **ì„ ì„ íƒí•˜ë©° MSTë¥¼ í™•ì¥.

### âš™ï¸ í•µì‹¬ ì•„ì´ë””ì–´

* ì •ì  ì¤‘ì‹¬(Greedy) ì ‘ê·¼ë²•
* ë°©ë¬¸í•˜ì§€ ì•Šì€ ì •ì  ì¤‘ **ìµœì†Œ ë¹„ìš© ê°„ì„ **ì„ ê³„ì† ì„ íƒ

---

### ğŸ’» ì½”ë“œ (Java)

```java
import java.util.*;

class Node implements Comparable<Node> {
    int vertex, cost;
    Node(int vertex, int cost) {
        this.vertex = vertex;
        this.cost = cost;
    }
    public int compareTo(Node o) {
        return this.cost - o.cost;
    }
}

public class Prim {
    static List<List<Node>> graph = new ArrayList<>();
    static boolean[] visited;

    static int prim(int start, int v) {
        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(start, 0));
        visited = new boolean[v + 1];

        int total = 0;

        while (!pq.isEmpty()) {
            Node cur = pq.poll();
            if (visited[cur.vertex]) continue;
            visited[cur.vertex] = true;
            total += cur.cost;

            for (Node next : graph.get(cur.vertex)) {
                if (!visited[next.vertex]) {
                    pq.offer(next);
                }
            }
        }
        return total;
    }
}
```

---

### ğŸ“Š ì‘ë™ íë¦„ ì˜ˆì‹œ

```
ì‹œì‘ ì •ì : 1
1 â†’ 2 (ë¹„ìš© 3)
2 â†’ 3 (ë¹„ìš© 4)

ì´ ë¹„ìš© = 7
```

---

### âš™ï¸ íŠ¹ì§•

| í•­ëª©     | ë‚´ìš©                        |
| ------ | ------------------------- |
| ì ‘ê·¼ ë°©ì‹  | Greedy (ì •ì  ì¤‘ì‹¬)            |
| ìë£Œêµ¬ì¡°   | PriorityQueue             |
| ì‹œê°„ ë³µì¡ë„ | O(E log V)                |
| ì¥ì      | ì¡°ë°€í•œ ê·¸ë˜í”„(Dense)ì— íš¨ìœ¨ì        |
| ë‹¨ì      | í¬ì†Œ ê·¸ë˜í”„(Sparse)ì—ì„œëŠ” ë‹¤ì†Œ ë¹„íš¨ìœ¨ì  |

---

# 4ï¸âƒ£ í¬ë£¨ìŠ¤ì¹¼ vs í”„ë¦¼ ë¹„êµ

| êµ¬ë¶„      | í¬ë£¨ìŠ¤ì¹¼             | í”„ë¦¼             |
| ------- | ---------------- | -------------- |
| ì ‘ê·¼ ë‹¨ìœ„   | ê°„ì„  ì¤‘ì‹¬            | ì •ì  ì¤‘ì‹¬          |
| êµ¬í˜„ ìë£Œêµ¬ì¡° | Union-Find       | Priority Queue |
| ì‹œê°„ ë³µì¡ë„  | O(E log E)       | O(E log V)     |
| ê·¸ë˜í”„ ìœ í˜•  | í¬ì†Œ ê·¸ë˜í”„(Sparse)   | ì¡°ë°€ ê·¸ë˜í”„(Dense)  |
| ëŒ€í‘œ ì‚¬ìš© ì˜ˆ | ë„ë¡œ ë„¤íŠ¸ì›Œí¬, ì—°ê²°ì„  ìµœì†Œí™” | ë„¤íŠ¸ì›Œí¬ ì¼€ì´ë¸” ì—°ê²°    |

---

# ğŸ§­ í•µì‹¬ ìš”ì•½

1. **MSTë€?** ëª¨ë“  ë…¸ë“œë¥¼ ì—°ê²°í•˜ëŠ” ìµœì†Œ ë¹„ìš©ì˜ íŠ¸ë¦¬.
2. **í¬ë£¨ìŠ¤ì¹¼:** ê°„ì„  ì¤‘ì‹¬, Union-Findë¡œ ì‚¬ì´í´ ë°©ì§€.
3. **í”„ë¦¼:** ì •ì  ì¤‘ì‹¬, ìµœì†Œ ë¹„ìš© ê°„ì„ ìœ¼ë¡œ í™•ì¥.

> âœ… ëª¨ë“  ìµœì†Œ ë¹„ìš© ì•Œê³ ë¦¬ì¦˜ì˜ í•µì‹¬ì€ **â€œì‚¬ì´í´ ë°©ì§€ + ìµœì†Œ ì„ íƒâ€**ì´ë‹¤.

---

# ğŸ§© ì‘ìš© í¬ì¸íŠ¸

* ì „ë ¥ë§, ë„ë¡œ, í†µì‹ ë§ êµ¬ì¶• ë¹„ìš© ì ˆê° ë¬¸ì œì— í™œìš©.
* í¬ë£¨ìŠ¤ì¹¼ì€ **ë¶„ë¦¬ëœ ë„¤íŠ¸ì›Œí¬ ì—°ê²°**, í”„ë¦¼ì€ **ê¸°ì¡´ ë„¤íŠ¸ì›Œí¬ í™•ì¥**ì— ìœ ë¦¬.

> ğŸ’¡ ì‚¬ê³  í¬ì¸íŠ¸: â€œì§€ê¸ˆê¹Œì§€ ì—°ê²°ëœ êµ¬ì¡°ë¥¼ ìœ ì§€í•˜ë©´ì„œ, ê°€ì¥ ì‹¸ê²Œ ì „ì²´ë¥¼ ì—°ê²°í•˜ë¼.â€
