# 🔍 **이분 탐색 (Binary Search) 정리**

## 📘 **개념**

**이분 탐색(Binary Search)** 은 **정렬된 배열에서 특정 값을 효율적으로 찾는 알고리즘**입니다.
전체 데이터를 절반씩 나누며 탐색하므로, **O(log n)** 의 빠른 시간 복잡도를 가집니다.

> ⚠️ 단, **데이터가 정렬되어 있어야만** 사용할 수 있습니다.

---

# 🧩 **작동 원리**

1. 탐색 구간의 **시작(start)** 과 **끝(end)** 을 설정합니다.
2. **중간(mid)** 인덱스를 계산하여 해당 값과 찾는 값을 비교합니다.
3. 찾는 값이 **중간값보다 작으면 왼쪽**, 크면 **오른쪽** 구간으로 이동합니다.
4. 구간이 더 이상 나눠지지 않을 때까지 반복합니다.

```
[1, 3, 5, 7, 9, 11, 13]
찾는 값: 9

1️⃣ mid = 3 (값=7) → 9 > 7 → 오른쪽 탐색
2️⃣ mid = 5 (값=11) → 9 < 11 → 왼쪽 탐색
3️⃣ mid = 4 (값=9) → ✅ 찾음!
```

---

# ⚙️ **시간 및 공간 복잡도**

| 구분     | 복잡도                       |
| ------ | ------------------------- |
| 시간 복잡도 | O(log n)                  |
| 공간 복잡도 | O(1) (반복문), O(log n) (재귀) |

---

# 💻 **예제 코드 (Java)**

## ✅ 반복문(Iterative) 방식

```java
public class BinarySearchIterative {
    public static int binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;

        while (left <= right) {
            int mid = (left + right) / 2;

            if (arr[mid] == target) return mid;
            else if (arr[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
        return -1; // 찾지 못한 경우
    }

    public static void main(String[] args) {
        int[] arr = {1, 3, 5, 7, 9, 11, 13};
        int target = 9;
        int result = binarySearch(arr, target);

        if (result != -1) System.out.println("찾은 인덱스: " + result);
        else System.out.println("값을 찾지 못했습니다.");
    }
}
```

## ✅ 재귀(Recursive) 방식

```java
public class BinarySearchRecursive {
    public static int binarySearch(int[] arr, int left, int right, int target) {
        if (left > right) return -1; // 탐색 종료

        int mid = (left + right) / 2;

        if (arr[mid] == target) return mid;
        else if (arr[mid] < target)
            return binarySearch(arr, mid + 1, right, target);
        else
            return binarySearch(arr, left, mid - 1, target);
    }

    public static void main(String[] args) {
        int[] arr = {1, 3, 5, 7, 9, 11, 13};
        int target = 9;
        int result = binarySearch(arr, 0, arr.length - 1, target);

        if (result != -1) System.out.println("찾은 인덱스: " + result);
        else System.out.println("값을 찾지 못했습니다.");
    }
}
```

---

# ⚖️ **이분 탐색의 장단점**

| 장점                     | 단점                  |
| ---------------------- | ------------------- |
| 매우 빠른 탐색 속도 (O(log n)) | 정렬된 배열에서만 사용 가능     |
| 구현이 간단하고 효율적           | 삽입/삭제가 자주 일어나면 비효율적 |

---

# 💡 **응용 예시**

| 분야                        | 설명                                |
| ------------------------- | --------------------------------- |
| 탐색 문제                     | 특정 값 존재 여부 검사 (예: 백준 1920번)       |
| Lower Bound / Upper Bound | 주어진 값 이상/초과의 첫 번째 위치 찾기           |
| 최적화 문제                    | 이분 탐색으로 조건 만족 최소/최대값 탐색 (매개변수 탐색) |

---

# 💬 **요약**

> **이분 탐색(Binary Search)** 은 정렬된 데이터에서 중간값을 기준으로 탐색 범위를 절반씩 줄이는 고효율 알고리즘입니다.
> 탐색 문제뿐 아니라 **매개변수 탐색(Parametric Search)**, **최적화 문제** 등에서도 널리 사용됩니다.
