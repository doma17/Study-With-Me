# 비선형 자료구조

비선형 자료구조는 데이터를 계층적 또는 네트워크 형태로 저장하고 관리하는 방식입니다. 
데이터들이 일렬로 나열되지 않고, 하나의 데이터 뒤에 여러 개의 데이터가 올 수 있는 구조를 가집니다.

아래의 비선형 자료구조에 대해서 살펴보겠습니다.

1.  그래프 (Graph)
2.  트리 (Tree)
3.  힙 (Heap)
4.  우선순위 큐 (Priority Queue)
5.  맵 (Map)
6.  셋 (Set)
7.  해시 테이블 (Hash Table)

## 1. 그래프 (Graph)

그래프는 정점(Vertex)과 그 정점을 연결하는 간선(Edge)으로 구성된 자료구조입니다. 연결된 객체 간의 관계를 표현하는 데 사용됩니다.

![그래프](https://laboputer.github.io/assets/img/algorithm/ds/06_graph2.PNG)

-   특징:
	-   정점(Vertex)과 간선(Edge)의 집합으로 표현됩니다.
	-   간선은 방향성이 있는 경우(Directed)와 없는 경우(Undirected)가 있습니다.
	-   간선에 가중치(Weight)를 두어 데이터 간의 관계의 강도나 비용을 나타낼 수 있습니다.
	-   네트워크 모델, 경로 찾기 등 다양한 문제에 활용됩니다.
-   구현 방법:
	-   인접 행렬 (Adjacency Matrix): 2차원 배열을 사용하여 정점 간의 연결 관계를 저장합니다. 정점의 개수가 V일 때 V x V 크기의 행렬이 필요합니다.
		-   장점: 두 정점의 연결 여부를 O(1)으로 빠르게 확인할 수 있습니다.
		-   단점: 간선의 수와 무관하게 O(V²)의 공간 복잡도를 가져 메모리 낭비가 있을 수 있습니다.
	-   인접 리스트 (Adjacency List): 각 정점에 연결된 정점들을 연결 리스트로 저장합니다.
		-   장점: 간선의 개수만큼만 공간을 차지하므로(O(V+E)) 공간 효율적입니다.
		-   단점: 두 정점의 연결 여부를 확인하려면 해당 정점의 리스트를 순회해야 하므로 인접 행렬보다 시간이 더 걸릴 수 있습니다(O(degree(V))).

## 2. 트리 (Tree)

트리는 그래프의 한 종류로, 계층적인 관계를 표현하는 자료구조입니다. 하나의 루트(Root) 노드에서 시작하여 여러 개의 자식 노드가 연결되는 방식이며, 사이클(Cycle)이 없는 연결 그래프입니다.

-   주요 용어:
	-   노드(Node): 트리를 구성하는 기본 요소. 데이터와 다른 노드를 가리키는 링크를 포함합니다.
	-   루트(Root): 트리 구조에서 최상위에 위치하는 노드.
	-   간선(Edge): 노드와 노드를 연결하는 선.
	-   부모(Parent)/자식(Child): 한 노드를 기준으로 바로 위 계층의 노드는 부모, 바로 아래 계층의 노드는 자식입니다.
	-   리프(Leaf): 자식 노드가 없는 맨 마지막 노드.

### 1. 이진 트리 (Binary Tree)

모든 노드가 최대 2개의 자식 노드를 가질 수 있는 트리입니다. 각 노드는 왼쪽 자식과 오른쪽 자식을 가집니다.

### 2. 완전 이진 트리 (Complete Binary Tree)

마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있으며, 마지막 레벨의 모든 노드는 가능한 한 왼쪽에 채워져 있는 이진 트리입니다.

### 3. 이진 탐색 트리 (Binary Search Tree, BST)

이진 트리의 일종으로, 데이터를 효율적으로 탐색하기 위해 특정 규칙에 따라 노드를 배치합니다.

![BST](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbCe3QD%2Fbtq2ytHuN1Z%2FAAAAAAAAAAAAAAAAAAAAALO2hxBZmvmkMrTvLK7Z5tWuNUOCSnTnClmhC0xXX-EC%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1761922799%26allow_ip%3D%26allow_referer%3D%26signature%3DMU%252B%252B%252FpaX6ZTQzxTxZQcWI75Kq8o%253D)

-   특징:
	-   각 노드의 왼쪽 서브트리에는 해당 노드의 값보다 작은 값을 가진 노드들만 포함됩니다.
	-   각 노드의 오른쪽 서브트리에는 해당 노드의 값보다 큰 값을 가진 노드들만 포함됩니다.
	-   모든 서브트리 또한 이진 탐색 트리입니다.
-   시간 복잡도 (트리가 균형 잡혀있을 경우):
	-   탐색, 삽입, 삭제: O(log n)
	-   최악의 경우(편향 트리): O(n)

## 3. 힙 (Heap)

힙은 완전 이진 트리에 기반한 자료구조로, 최댓값이나 최솟값을 빠르게 찾아내기 위해 사용됩니다.

![힙](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FqlAPT%2FbtrwsI1jriu%2FAAAAAAAAAAAAAAAAAAAAACl2I8OJL77Fw6qVJKFAi2kTVv0LysmPG3K718v9Fd-Y%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1761922799%26allow_ip%3D%26allow_referer%3D%26signature%3DrNu5ArdsgSSBSsQ8H3WnKrPY44Q%253D)

-   특징:
	-   최대 힙(Max Heap): 부모 노드의 키 값은 항상 자식 노드의 키 값보다 크거나 같습니다.
	-   최소 힙(Min Heap): 부모 노드의 키 값은 항상 자식 노드의 키 값보다 작거나 같습니다.
	-   루트 노드는 항상 데이터의 최댓값(최대 힙) 또는 최솟값(최소 힙)을 가집니다.
-   시간 복잡도:
	-   삽입 (Insert): O(log n)
	-   삭제 (Delete): O(log n)
	-   최댓값/최솟값 확인 (Peek): O(1)

## 4. 우선순위 큐 (Priority Queue)

우선순위 큐는 주로 힙으로 구현됩니다. 일반적인 큐의 선입선출(FIFO) 방식과 달리, 데이터의 우선순위에 따라 출력 순서가 결정되는 자료구조입니다.

![PQ](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FcYESG0%2Fbtq7tY1JSrS%2FAAAAAAAAAAAAAAAAAAAAACDpU3HVvlIvNib7igSMp9PnYX3UaAfO1Ncs2lo7P-Gz%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1761922799%26allow_ip%3D%26allow_referer%3D%26signature%3DwMtUCfTDC9Xl0MJ36nXaVhPNB58%253D)

-   특징:
	-   우선순위가 높은 데이터가 먼저 처리됩니다.
	-   힙으로 구현 시, 삽입 및 삭제 연산이 O(log n)의 시간 복잡도를 가집니다.

## 5. 맵 (Map)

맵은 키(Key)와 값(Value)을 하나의 쌍으로 묶어 저장하는 자료구조입니다. 키를 통해 값을 빠르게 찾아낼 수 있습니다.

![맵](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTO8ZOmjTmAsiD99oqQ_UTFEKhUjJIvGpyRlw&s)

-   특징:
	-   키는 고유해야 하며, 중복될 수 없습니다.
	-   값은 중복될 수 있습니다.
	-   Java - `HashMap`, `TreeMap` 등의 클래스로 구현됩니다. 

## 6. 셋 (Set)

셋은 순서 없이, 중복되지 않는 데이터의 집합을 저장하는 자료구조입니다.

-   특징:
	-   데이터의 중복을 허용하지 않습니다.
	-   데이터의 존재 여부를 빠르게 확인할 때 유용합니다.
	-   Java - `HashSet`, `TreeSet` 등의 클래스로 구현됩니다.
    

## 7. 해시 테이블 (Hash Table)

해시 테이블은 키를 값에 매핑할 수 있는 구조로, 해시 함수(Hash Function)를 사용하여 키를 배열의 인덱스로 변환하여 데이터를 저장합니다. 이를 통해 매우 빠른 데이터 검색, 삽입, 삭제가 가능합니다.

![해시 테이블](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FVGNn8%2FbtsLjahR9JC%2FAAAAAAAAAAAAAAAAAAAAAAFUVnf_N1KpZbBI5mqM4rK7q1BDmjVc2KOvoxACtDpr%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1761922799%26allow_ip%3D%26allow_referer%3D%26signature%3DdOsitaY2pmeuDsj7yDbcEA2kZTk%253D)

-   특징:
	-   해시 함수를 통해 키를 해시 값(배열의 인덱스)으로 변환합니다.
	-   서로 다른 키가 같은 해시 값으로 변환되는 해시 충돌(Hash Collision)이 발생할 수 있습니다.
	-   충돌 해결 방법:
		-   체이닝(Chaining): 동일한 해시 값으로 매핑되는 데이터들을 연결 리스트로 관리합니다.
		-   개방 주소법(Open Addressing): 충돌 발생 시 다른 비어있는 버킷을 찾아 데이터를 저장합니다.
-   시간 복잡도 (충돌이 적은 이상적인 경우):
	-   검색, 삽입, 삭제: O(1)
	-   최악의 경우(모든 데이터가 하나의 버킷에 충돌): O(n)

## Reference 

https://yoongrammer.tistory.com/71
https://currygamedev.tistory.com/20