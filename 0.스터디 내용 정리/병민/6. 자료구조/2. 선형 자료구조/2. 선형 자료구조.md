# 선형 자료구조

선형 자료구조는 데이터를 순차적으로 저장하고 관리하는 방식입니다. 데이터들이 일렬로 나열된 형태를 가지며, 각 데이터는 이전 데이터와 다음 데이터와의 관계를 가집니다.

아래의 선형 자료구조에 대해서 살펴보겠습니다.

1. 배열 (Array)
2. 연결 리스트 (Linked List)
3. 벡터 (Vector - 동적배열, ArrayList)
4. 스택 (Stack)
5. 큐 (Queue)

## 1. 배열 (Array)

배열은 가장 기본적인 선형 자료구조로, 동일한 타입의 데이터 여러 개를 연속된 메모리 공간에 저장합니다. 각 데이터는 인덱스(index)를 통해 직접 접근할 수 있습니다.

![베열](https://velog.velcdn.com/images/soso/post/9ad1cf20-f5ee-4c9b-837f-5f6960e7b6ac/image.png)

-   특징:
	-   고정된 크기를 가집니다.
	-   인덱스를 통한 빠른 접근(O(1))이 가능합니다.
	-   데이터를 삽입하거나 삭제할 때, 해당 위치 이후의 모든 데이터를 이동시켜야 하므로 비용이 많이 듭니다(O(n)).
-   시간 복잡도:
	-   접근: O(1)
	-   검색, 삽입, 삭제: O(n)

## 2. 연결 리스트 (Linked List)

연결 리스트는 여러 개의 노드(Node)가 순차적으로 연결된 형태를 갖는 자료구조입니다. 각 노드는 데이터와 다음 노드를 가리키는 포인터(주소)로 구성됩니다.

![연결 리스트](https://media.geeksforgeeks.org/wp-content/uploads/20210409184741/HowtoImplementGenericLinkedListinJava.jpg)

-   특징:
	-   크기가 동적으로 변할 수 있습니다.
	-   데이터의 삽입과 삭제가 용이합니다(O(1)).
	-   특정 위치의 데이터에 접근하려면 처음부터 순차적으로 탐색해야 하므로 접근 속도가 느립니다(O(n)).
	-   포인터를 저장하기 위한 추가적인 메모리 공간이 필요합니다.
-   시간 복잡도:
	-   접근: O(n)
	-   검색: O(n)
	-   삽입, 삭제: O(1) (맨 앞/뒤), O(n) (중간)

## 3. 벡터 (Vector - 동적배열, ArrayList)

백테(Vector, ArrayList)는 동적으로 크기가 조절되는 배열입니다. 내부적으로는 정적 배열을 사용하지만, 배열의 크기가 가득 차면 더 큰 새로운 배열을 생성하고 기존 요소들을 복사하여 크기를 확장합니다.

![ArrayList](https://hudi.blog/static/1238df8376f690806eb414b6e1889b6a/f5f2a/3.png)

-   특징:
	-   배열과 같이 인덱스를 통해 데이터에 빠르게 접근할 수 있습니다(O(1)).
	-   데이터가 추가될 때 자동으로 크기가 조절됩니다.
	-   `Vector`와 달리 동기화(synchronized)를 지원하지 않으므로, 단일 스레드 환경에서 더 나은 성능을 보입니다.
	-   중간에 데이터를 삽입하거나 삭제하는 경우, 해당 지점 이후의 모든 요소를 이동시켜야 하므로 비용이 많이 듭니다(O(n)).
-   시간 복잡도:
	-   접근: O(1)
	-   맨 뒤에 삽입/삭제: O(1)\
	-   중간에 삽입/삭제: O(n)

## 4. 스택 (Stack)

스택은 후입선출(LIFO, Last-In, First-Out) 원칙에 따라 데이터를 관리하는 자료구조입니다. 가장 마지막에 삽입된 데이터가 가장 먼저 삭제됩니다.

![Stack](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20230726165552/Stack-Data-Structure.png)

-   특징:
	-   데이터의 입력을 `Push`, 출력을 `Pop`이라고 합니다.
	-   가장 위에 있는 데이터를 확인하는 연산은 `Peek` 또는 `Top`이라고 합니다.
	-   배열이나 연결 리스트를 사용하여 구현할 수 있습니다.
-   시간 복잡도 (배열 또는 연결 리스트 구현 기준):
	-   Push: O(1)
	-   Pop: O(1)
	-   Peek: O(1)

## 5. 큐 (Queue)

큐는 선입선출(FIFO, First-In, First-Out) 원칙에 따라 데이터를 관리하는 자료구조입니다. 가장 먼저 삽입된 데이터가 가장 먼저 삭제됩니다.

![Queue](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbhvAPe%2FbtqHlVqf0RY%2FAAAAAAAAAAAAAAAAAAAAALk-y1WEeUVnq8KtkluRxaWvI1B5SG8lplF-k4nPbxS2%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1761922799%26allow_ip%3D%26allow_referer%3D%26signature%3DPaFsqOq5RPpp7uZGgh6L41QRRME%253D)

-   특징:
	-   데이터의 입력을 `Enqueue`, 출력을 `Dequeue`라고 합니다.
	-   배열이나 연결 리스트를 사용하여 구현할 수 있습니다.
-   시간 복잡도 (연결 리스트 구현 기준):
	-   Enqueue: O(1)
	-   Dequeue: O(1)
	-   Peek: O(1)

## Reference

https://velog.io/@soso/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EB%B0%B0%EC%97%B4-Array
https://www.geeksforgeeks.org/array-data-structure/
https://coding-factory.tistory.com/602