# 인증 방식

## Session 인증 

- 개념: 서버가 사용자에 대한 세션 상태를 저장하고, 클라이언트는 세션 식별자(보통 세션 쿠키)를 전송해 인증을 유지합니다.
- 동작 흐름:
  1. 사용자가 로그인하면 서버는 세션을 생성하고 세션 ID를 발급합니다.
  2. 세션 ID는 HttpOnly, Secure 속성의 쿠키로 클라이언트에 전달됩니다.
  3. 클라이언트는 이후 요청에 해당 쿠키를 포함해 서버에 보냅니다. 서버는 세션 저장소에서 세션 정보를 조회해 인증 상태를 확인합니다.
- 장점:
  - 서버에서 세션을 직접 제어 가능하므로 토큰 무효화, 강제 로그아웃 구현이 쉽습니다.
  - 민감한 정보(토큰 등)를 브라우저에 저장하지 않으므로 XSS 공격 노출을 줄일 수 있습니다(단, CSRF에 취약할 수 있습니다).
- 단점 및 한계:
  - 수평 확장이 필요한 환경에서는 세션 저장소를 공유해야 합니다(Redis, Memcached 등). 관리 비용이 발생합니다.
  - 서버 측 상태가 필요하므로 완전 무상태(stateless) 아키텍처와 충돌합니다.
  - CSRF 공격에 취약하므로 CSRF 토큰, SameSite, CORS 정책 등 방어책이 필요합니다.
- 확장성 전략:
  - 세션을 중앙 저장소(Redis)로 옮겨 여러 앱 인스턴스에서 공유합니다.
  - 세션 만료 정책, 세션 갱신 전략을 명확히 둡니다.
- 보안 권장사항:
  - 세션 쿠키에 HttpOnly와 Secure를 설정합니다.
  - SameSite=strict 또는 Lax를 적절히 설정합니다(서비스 특성에 따라 결정).
  - 세션 ID는 충분히 랜덤하고 긴 값으로 생성합니다.

## JWT 인증

- 개념: JWT(Json Web Token)를 발급해 클라이언트가 이 토큰을 사용해 인증을 진행합니다. 토큰 자체에 인증 정보(claims)를 담아 서버에서 별도 상태 없이 검증할 수 있습니다.
- 동작 흐름:
  1. 사용자가 인증하면 서버는 access token(JWT)과 필요 시 refresh token을 발급합니다.
  2. 클라이언트는 access token을 Authorization 헤더(Bearer)로 전송하거나, HttpOnly 쿠키로 전송해 API를 호출합니다.
  3. 서버는 토큰 서명, 만료(exp), issuer(aud/iss)를 검증해 요청을 허용합니다.
- 저장 방식 비교:
  - Authorization: Bearer <TOKEN>
    - 장점: 가장 일반적이고 RESTful한 방식입니다. CORS, CSRF 설정에 유의해야 합니다.
    - 단점: 브라우저에서 localStorage에 토큰을 저장하면 XSS에 취약합니다.
  - HttpOnly Secure Cookie
    - 장점: JS에서 접근 불가(HttpOnly)로 XSS 피해 위험이 낮습니다. 브라우저가 자동으로 전송하므로 편리합니다.
    - 단점: CSRF 공격 가능성 존재. CSRF 방어(CSRF 토큰, SameSite) 필요합니다.
- 토큰 갱신/만료 전략:
  - Access token은 짧게 설정(예: 몇 분~한 시간).
  - Refresh token은 안전하게 보관하고, 로테이션(Token Rotation) 혹은 슬라이딩(Sliding) 전략을 사용해 보안을 보강합니다.
  - 추가 방식:
    - Opaque(참조) 토큰: refresh token을 opaque ID로 발급해 서버에서 조회·검증합니다.
    - Revocation/Introspection: 토큰 상태를 서버에서 실시간 조회하거나 무효화합니다.
    - Proof of Possession(DPoP/PoP): 토큰 사용을 클라이언트의 키와 결합해 단순 탈취로는 사용할 수 없게 합니다.
- 장점:
  - 서버에 세션 상태를 두지 않아 무상태로 확장성이 좋습니다.
  - JWT 자체에 권한(scope)을 담아 빠른 검증이 가능합니다.
- 단점:
  - 토큰 탈취 시 무단 사용 위험이 큽니다(특히 장기 수명 토큰).
  - 발급 후 토큰 내용을 변경하거나 즉시 무효화하기 어렵습니다(opaque 또는 revocation으로 보완 가능).
- 실무 권장사항:
  - access token은 가능한 짧게, refresh token은 로테이션과 저장 해시를 사용합니다.
  - 브라우저에서는 HttpOnly Secure Cookie를 우선 고려하고, 반드시 CSRF 방어를 병행합니다.
  - 토큰 무효화와 모니터링(로그, 이상행동 탐지)을 구현합니다.

### 간단한 예시

- Authorization 헤더로 전송하는 경우:

```
GET /api/user/profile HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
```

- HttpOnly 쿠키로 전송하는 경우(서버에서 Set-Cookie 예):

```
Set-Cookie: ACCESS_TOKEN=<JWT>; HttpOnly; Secure; SameSite=Lax; Path=/; Max-Age=300
```
