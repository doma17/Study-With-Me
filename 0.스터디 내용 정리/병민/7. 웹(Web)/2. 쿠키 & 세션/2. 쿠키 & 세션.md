# 쿠키 & 세션

웹에서 쿠키와 세션이 왜 필요할까요?

쿠키와 세션은 웹에서 사용자 상태(정보)를 유지하고 인증, 인가를 위해서 필요합니다.

HTTP 기본적으로 stateless로 동작합니다. 따라서 서버가 클라이언트를 구분하지 못합니다.
따라서 쿠키와 세션으로 서버는 클라이언트를 구분하기 위해서 사용합니다.

## 1. Cookie - 쿠키

1. 서버는 `Set-Cookie`를 통해서 쿠키를 브라우저에 전달합니다.
2. 브라우저는 이 헤더를 브라우저 저장소에 key-value 형태로 저장하빈다.
3. 이후 같은 도메인으로 요청을 보낼 때마다 브라우저는 `Cookie` 헤더에 이 쿠키 값을 포함시켜 전송합니다.
4. 서버는 해당 쿠키 정보를 바탕으로 사용자를 식별하고 연동하여 상태를 관리합니다.

<img src="https://velog.velcdn.com/images/soogineer/post/87cf3376-a4b9-431b-b084-0d1dd4116d51/image.png" style="max-width:80%; height:auto;" />

### 1-1. 쿠키의 주요속성

- Domain: 쿠키가 전송될 도메인을 지정해, 특정 도메인 요청에서만 쿠키가 포함되도록합니다. 
- Path: 쿠키가 유효한 URL 경로를 지정합니다.
- Expires or Max-Age: 쿠키의 유효기간을 설정해 기간이 지나면 자동으로 삭제되도록 합니다.
- Secure: HTTPS 환경에서만 쿠키가 전송되도록 합니다.
- HttpOnly: 자바스크립트에서 접근 불가능하도록 만들어 보안성을 높입니다. 

### 1-2. 쿠키 사용 예시

JWT Token - Access/Refresh Token 전략이 있습니다.

<img src="https://www.miniorange.com/blog/assets/2023/jwt-structure.webp" style="max-width:80%; height:auto;" />

JWT(Json Web Token) Token에 대해서는 추가적으로 공부해보는 것을 추천드립니다.
> JWT 토큰은 `header.payload.signature`로 구성됩니다.

쿠키 기반 JWT 인증은 JWT의 확장성과 보안성, 그리고 쿠키의 자동 전송 편의성을 결합한 방식입니다.
HttpOnly 및 Secure, SameSite 속성을 통해 주요 웹 공격(특히 XSS, CSRF)을 방어하면서, 서버 상태 저장 부담 없이 효율적인 인증 시스템을 설계할 수 있습니다. 
이 방식은 세션 기반 인증의 단점을 보완하는 현대적인 예시라고 볼 수 있습니다.

## 2. Session - 세션

세션은 웹에서 사용자의 상태를 서버에 저장하여 HTTP 프로토콜의 stateless 특성을 보완하는 역할을 합니다.

### 2-1. 세션의 동작원리

- 사용자가 로그인 등 요청을 할 때 서버는 고유한 세션 ID를 생성합니다.
- 서버는 이 세션 ID와 함께 사용자의 상태 정보(예: 로그인 정보)를 서버 메모리, DB, 캐시 등에 저장합니다.
- 세션 ID는 클라이언트에게 쿠키 형태로 전달되고, 브라우저는 이후 요청 시마다 이 쿠키를 서버에 자동으로 전송합니다.
- 서버는 받은 세션 ID로 저장된 상태 정보를 찾아 사용자를 식별하고 요청을 처리합니다.
- 세션은 일정 시간이 지나면 만료되어 사용자 상태가 종료됩니다.

> Tomcat을 사용하면 브라우저에 자동으로 JSESSIONID가 저장되는 것을 알 수 있습니다.

만약에 Load Balancer를 통해서 여러 대의 서버로 트래픽을 분산처리 할때 세션을 사용할 수 있을까요?

이러한 로드밸런서를 사용할 때 어려운 문제 중 하나는 세션 데이터를 관리해야 한다는 것입니다.
세션을 관리하는 방법도 여러가지 인데요. 아래와 다양한 세션 구성방법을 알아봅시다.

### 2-2. 세션 구성법

#### 1. Sticky Session

Sticky Session은 말 그대로 세션 기간 동안 동일한 클라이언트의 요청을 같은 서버로 계속 보내는 것입니다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FcwhyO8%2FbtsgeyUa7RD%2FAAAAAAAAAAAAAAAAAAAAAFr1aOXCooS89Wl6FoXBd7E9VA0tERpjSzEy2MZFsAb6%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1761922799%26allow_ip%3D%26allow_referer%3D%26signature%3Ds7mJ5MyKIR%252FATOBBe1LFt9RiRuY%253D" style="max-width:80%; height:auto;" />

- 장점
  - 여러 서버들은 세션 데이터를 교환할 필요가 없다.
  - 정합성 이슈에서 자유로워 진다.
- 단점
  - 특정 서버에 과부하가 발생할 수 있으며, 트래픽이 균등하게 배분될 수 없다.
  - 로드밸런싱으로 인해 트래픽이 분산되긴 하지만, Sticky Session을 사용했을 때 특정 서버에 몰린 사람들만 활발하게 활동하는 경우 해당 서버만 과부하가 걸릴 수 있다.

하지만 이러한 상황에서 WAS1에서 장애가 생겨 인스턴스가 내려가면 어떻게 해야할까요? WAS1을 사용하던 유저들은 WAS2를 이용해 로그인을 다시 수행해야합니다.
이러한 단점으로 인해서 아래의 Session Cluster 방식이 고민되고 있는 것입니다.

#### 2. Sesssion Clustering

1. All to All Session Replication
   - 서버끼리 모든 세션 정보를 복제해 저장.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbfXWdP%2Fbtsf4foVors%2FAAAAAAAAAAAAAAAAAAAAAANMEf5lGVM3W4naU9BG_VQrCRVZyV5goTZkS_3WfFt2%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1761922799%26allow_ip%3D%26allow_referer%3D%26signature%3DE2Kyj5e7uuW9Xdew6jjNyuRybnw%253D" style="max-width:80%; height:auto;" />

2. primary-secondary Session Replication
   - primary와 secondary 서버에서만 해당 전체 도메인의 세션을 복제해두고 다른 서버들은 세션 정보가 필요할때 질의하게 됩니다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbmwL2w%2FbtsgbKaDEeN%2FAAAAAAAAAAAAAAAAAAAAAIftROSR0e-pLeu_cK9hq4zNVLTKXGhSYYfsLntnGFXU%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1761922799%26allow_ip%3D%26allow_referer%3D%26signature%3DnLTvf1ggs3dRjXk3YmM1Q3F1AWQ%253D" style="max-width:80%; height:auto;" />

3. Session Storage
   - 이러한 위의 방법들의 문제를 해결하기 위해서 별도의 Session Storage를 운영하는 방법이 있습니다.
   - 주로 RRedis Memcached 등의 세션 저장소가 사용됩니다.

<img src="https://velog.velcdn.com/images/whereisdw/post/aee79ca9-5ae2-48c7-b104-dfd39e2d0487/image.png" style="max-width:80%; height:auto;" />
