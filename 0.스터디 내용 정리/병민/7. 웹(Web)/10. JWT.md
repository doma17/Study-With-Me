# JWT Json Web Token

## JWT 구성요소

![JWT](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2Fb0nX6m%2FbtsHIIWPhFw%2FAAAAAAAAAAAAAAAAAAAAAD7mvc4m6Vqj91zpHI2eGABfFyLHQjyyeiFIVbJ5GODI%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1764514799%26allow_ip%3D%26allow_referer%3D%26signature%3DgIYCsWxXsdePV%252BohpyvYG2DZrCs%253D)

- JWT는 세 부분(header.payload.signature)으로 구성됩니다. 각 부분은 base64url로 인코딩됩니다.
  - header: alg(서명 알고리즘), typ, kid 등 메타 정보입니다.
  - payload: claims(iss, sub, aud, exp, iat, nbf, jti 등)을 포함합니다.
  - signature: header와 payload를 비밀키로 서명한 값입니다.
- 서명 알고리즘: HS256(대칭 키), RS256/ES256(비대칭 키) 등이 주로 사용됩니다. 운영 환경에서는 키 관리가 쉬운 공개키 기반(RS/ES)을 권장합니다.
- 검증 시 필수로 확인할 항목: signature, exp(만료), nbf(발행 전), aud(대상), iss(발행자), jti(중복/무효화 추적 필요 시)입니다.

![JWT-content](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbwmwBq%2FbtrqGVel5Qk%2FAAAAAAAAAAAAAAAAAAAAACGDUfkfoew8M5xzabdhZZ1pLxMnnnVz0_Wrdetplosz%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1764514799%26allow_ip%3D%26allow_referer%3D%26signature%3DVRPlVVSCLut1T7gbZIUASsTgN6w%253D)

## salt를 통한 해싱 방법

- JWT 자체는 서명(sign)으로 무결성을 보장하므로 payload에 salt를 넣는 방식은 일반적이지 않습니다. 다만 리프레시 토큰을 DB에 저장할 때는 평문으로 저장해서는 안 됩니다.
- 리프레시 토큰 보관 권장 방법: 토큰 자체를 해시(scrypt/argon2 또는 SHA-256)하고, salt를 붙여 해시값만 DB에 저장합니다. 실제 토큰은 발급 시 클라이언트에만 전달합니다.
  - 예: store_hash = H(salt + refresh_token)
  - 검증 시 클라이언트가 제출한 refresh_token에 같은 salt를 적용해 해시를 비교합니다.
- salt는 각 토큰별로 랜덤하게 생성하고, DB에 salt값(또는 salt가 포함된 해시 인코딩)과 함께 저장합니다. 토큰 탈취 시 DB가 유출되더라도 원본 토큰을 바로 악용하지 못하도록 합니다.

## JWT Refresh Token에 대한 보안 추가

- 기본 원칙: access token은 짧게, refresh token은 비교적 길게 두되 refresh token의 안전한 보관과 사용 검증을 반드시 구현합니다.
- 보안 기법 요약:
  - 토큰 로테이션(Token Rotation): refresh 토큰을 사용해 새로운 access/refresh 쌍을 발급할 때 기존 refresh 토큰을 무효화하고 새로운 refresh 토큰을 발급합니다. 재사용(reuse) 감지가 가능하면 악성 재사용 시 세션을 차단합니다.
  - 슬라이딩(Sliding): refresh 토큰 사용 시 만료 시간을 연장합니다. 사용 빈도에 따라 세션을 유지시키는 방식입니다. 일반적으로 로테이션과 같이 사용해 재사용 공격을 줄입니다.
  - 블랙리스트(denylist): 유효한 토큰 목록에서 강제로 차단하는 방식입니다. DB 또는 인메모리 캐시(redis)에 무효화된 jti를 기록해 검증 시 체크합니다.
  - 화이트리스트(allowlist): 발급된 토큰을 서버에 기록하고, 토큰이 서버에 존재할 때만 유효하다고 판단합니다. 세션 상태를 유지하기 때문에 완전 무상태(stateless)의 장점을 일부 포기합니다.
  - 참조 토큰(Reference Token) / Opaque Token: 토큰 자체에 정보가 담기지 않고, 단순 식별자 형태로 발급합니다. 서버에서 토큰 ID를 조회해 권한을 확인하므로 토큰 무효화가 용이합니다.
  - Proof-of-Possession (PoP) / DPoP: 토큰을 단순 소지 기반이 아닌 클라이언트의 키와 연동해 사용합니다. 중간자 공격에서 토큰 재사용을 어렵게 만듭니다.

### Token Rotate (토큰 로테이션)

- 동작: 클라이언트가 refresh token으로 토큰을 교환하면 서버는 기존 refresh token을 즉시 무효화하고 새로운 refresh token을 발급합니다.
- 장점: refresh token 재사용이 감지되면 즉시 세션을 차단할 수 있습니다.
- 구현 포인트:
  - refresh token의 jti를 DB에 기록하고, 사용 시 확인 후 삭제(또는 만료 처리)합니다.
  - 재사용 감지: 이미 사용된 jti가 다시 제출되면 탈취로 간주하고 관련 세션 모두 차단합니다.

### Token Sliding (슬라이딩 세션)

- 동작: refresh token이 사용될 때마다 만료 시간을 연장합니다(또는 새로운 토큰을 발급하여 만료 시간을 늘립니다).
- 장점: 사용자가 자주 이용하면 자동으로 세션을 유지할 수 있습니다.
- 단점: 적절한 최대 만료 한계가 필요합니다(무한정 연장 방지).

## 기타 토큰 전략 및 방식

- Opaque/Reference Token
  - 토큰 자체가 의미를 갖지 않고 ID 역할만 수행합니다. 토큰 유효성 확인을 위해 서버에서 조회(introspection)를 수행합니다.
  - 장점: 토큰 탈취 시 서버에서 즉시 무효화할 수 있습니다. 단점: 매 요청마다 서버 조회 비용이 소모됩니다.
- Self-contained JWT
  - 토큰 자체에 권한 정보를 담는 방식입니다. 무상태(stateless)로 확장성이 좋습니다. 단점: 발급 후 토큰 내용 변경이나 무효화가 어렵습니다.
- Hybrid
  - access token은 JWT(self-contained), refresh token은 opaque로 사용하는 방식이 현실적입니다. access token은 빠른 검증을 위해 JWT로, refresh는 서버에서 제어하기 위해 opaque로 둡니다.
- Revocation/Introspection 엔드포인트
  - OAuth2 표준에서 제공하는 토큰 무효화(revocation)와 토큰 introspection 엔드포인트를 활용합니다. 내부적으로 토큰 상태를 조회하거나 취소할 수 있습니다.
- JWT의 Key Rotation
  - 공개키(JWKs) 엔드포인트를 제공하고, header의 kid로 키를 식별해 서명을 검증합니다. 주기적인 키 로테이션으로 키 노출 위험을 줄입니다.

## 실무 권장 사항

- access token은 짧게(예: 몇 분~한 시간), refresh token은 안전하게 보관하되 로테이션 적용을 권장합니다.
- refresh token은 DB에 해시로 저장하고, 토큰 재사용을 감지하는 로직을 구현합니다.
- 토큰 발급 시 scope(권한)을 최소화하고, aud/iss를 정확히 검증합니다.
- HTTPS 적용은 필수이고, 브라우저 저장소로는 HttpOnly Secure Cookie를 우선 고려합니다. localStorage 사용은 XSS 위험 때문에 권장하지 않습니다.
- 가능하면 opaque refresh token + JWT access token 조합을 사용합니다.
- 토큰 무효화와 모니터링(로그, 이상행동 탐지)을 함께 구현합니다.
