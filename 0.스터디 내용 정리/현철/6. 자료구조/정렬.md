# 정렬 알고리즘 (Sorting Algorithms)

정렬(Sorting)은 데이터를 일정한 기준에 따라 순서대로 재배치하는 과정.

## 선택 정렬 (Selection Sort)
### 개념
가장 작은(또는 큰) 값을 찾아 앞쪽부터 차례로 배치하는 방식의 정렬. 한 번의 루프마다 남은 데이터 중 최솟값을 선택 → 맨 앞 원소와 교환.

### 동작 원리
예시: [5, 3, 8, 4, 2]
1. 전체에서 가장 작은 값(2)을 찾아 첫 번째 원소(5)와 교환 → [2, 3, 8, 4, 5]
2. 나머지 [3, 8, 4, 5]에서 최솟값(3)을 두 번째 자리에 둠 → [2, 3, 8, 4, 5]
3. [8, 4, 5]에서 최솟값(4)을 세 번째 자리에 둠 → [2, 3, 4, 8, 5]
4. [8, 5] 중 최솟값(5) → [2, 3, 4, 5, 8]

### 시간 복잡도
최선, 평균, 최악 모두 O(N²). 교환 횟수는 최대 N-1회로 적지만, 비교는 많이 발생함

## 거품 정렬 (Bubble Sort)
### 개념
인접한 두 원소를 비교하여 큰 값을 뒤로 보내는 방식의 정렬. 마치 “큰 수가 거품처럼 위로 올라간다”고 해서 Bubble Sort라 불림.

### 동작 원리
예시: [5, 3, 8, 4, 2]
1. (5,3) → 교환 → [3,5,8,4,2]
2. (5,8) → 그대로
3. (8,4) → 교환 → [3,5,4,8,2]
4. (8,2) → 교환 → [3,5,4,2,8] → 1회전 후, 가장 큰 값 8이 맨 뒤로 이동

이 과정을 (N-1)번 반복.

### 시간 복잡도
- 최악, 평균: O(N²).
- 최선(이미 정렬된 경우): O(N) (교환이 없을 경우 조기 종료 가능)

## 삽입 정렬 (Insertion Sort)
### 개념
이미 정렬된 부분 리스트에 새 데이터를 적절한 위치에 삽입하여 정렬을 완성. 카드 정렬할 때 손안의 카드를 순서대로 끼워 넣는 것과 비슷.

### 동작 원리
예시: [5, 3, 8, 4, 2]
1. 첫 번째 원소는 정렬된 상태로 간주
2. 두 번째 원소(3)를 앞쪽(5)과 비교 → [3,5,8,4,2]
3. 세 번째 원소(8)는 그대로
4. 네 번째 원소(4) → 8보다 작고 5보다 작음 → [3,4,5,8,2]
5. 마지막(2) → [2,3,4,5,8]

### 시간 복잡도
| 경우         | 복잡도   |
| ---------- | ----- |
| 최선(이미 정렬됨) | O(N)  |
| 평균         | O(N²) |
| 최악(역순 정렬)  | O(N²) |

## 병합 정렬 (Merge Sort)
### 개념
리스트를 반으로 나눈 뒤 각각을 정렬하고, 두 개의 정렬된 리스트를 병합(merge)하여 완성하는 알고리즘입니다.

### 동작 원리
예시: [5, 3, 8, 4, 2]
1. [5,3,8,4,2] → [5,3,8], [4,2]로 분할
2. 각각 정렬 → [3,5,8], [2,4]
3. 병합 → [2,3,4,5,8] 

### 시간 복잡도
| 구분     | 복잡도             |
| ------ | --------------- |
| 전체     | O(N log N)      |
| 공간 복잡도 | O(N) (보조 배열 필요) |

## 퀵 정렬 (Quick Sort)
### 개념
피벗(Pivot)을 기준으로 작은 값과 큰 값을 분할하여 정렬하는 분할 정복 알고리즘. 

### 동작 원리
예시: [5, 3, 8, 4, 2], 피벗=5
1. 피벗 기준으로 작은 값 [3,4,2], 큰 값 [8]으로 분할
2. [3,4,2]를 재귀 정렬 → [2,3,4]
3. 최종: [2,3,4,5,8]

### 시간 복잡도
| 경우                 | 복잡도        |
| ------------------ | ---------- |
| 평균                 | O(N log N) |
| 최악(정렬된 상태 피벗 선택 시) | O(N²)      |

## 힙 정렬 (Heap Sort)
### 개념
힙(Heap) 자료구조를 이용한 정렬로, 완전이진트리 형태의 최대 힙(Max Heap) 또는 최소 힙(Min Heap)을 구성하여 최댓값(또는 최솟값)을 하나씩 꺼내 정렬.

### 동작 원리
예시: [5, 3, 8, 4, 2]
1. 최대 힙 생성 → 루트(8)는 항상 가장 큼
2. 루트(8) ↔ 마지막 원소(2) 교환 → [2,3,5,4,8]
3. 힙 크기를 줄이고 다시 최대 힙화 → [5,4,2,3,8]
4. 반복 → [2,3,4,5,8]

### 시간 복잡도
| 단계   | 복잡도        |
| ---- | ---------- |
| 힙 구성 | O(N)       |
| 힙 정렬 | O(N log N) |
| 전체   | O(N log N) |
