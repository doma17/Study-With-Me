# 이분 탐색 (Binary Search)
이분 탐색(Binary Search) 은 정렬된 배열에서 원하는 값을 효율적으로 찾는 알고리즘. 단순히 처음부터 끝까지 탐색하는 선형 탐색(Linear Search, O(N))과 달리, 탐색 범위를 절반씩 줄여나가며 검색하기 때문에 O(log N)의 시간 복잡도를 가짐
즉, "데이터가 정렬되어 있다"는 전제 조건 하에서 탐색 속도를 획기적으로 개선가능.

## 동작 원리
이분 탐색의 핵심 아이디어는 중간값(mid)을 기준으로 탐색 범위를 절반으로 줄이는 것.

예시 배열이 [2, 4, 7, 9, 13, 15, 18]이고,
찾고자 하는 값이 13이라면 다음과 같이 진행:
```text
1. 중간값(mid) 찾기 → (0 + 6)/2 = 3 → arr[3] = 9
→ 9 < 13 → 오른쪽 구간으로 이동

2. 새 구간: [13, 15, 18]
중간값(mid) = (4 + 6)/2 = 5 → arr[5] = 15
→ 15 > 13 → 왼쪽 구간으로 이동

3. 새 구간: [13]
arr[4] = 13 → 찾음
```

이처럼 탐색 범위가 매번 절반씩 감소하므로,
7개의 데이터라면 최대 약 log₂(7) ≈ 3번의 비교로 탐색이 완료

## 구현 방법
이분 탐색은 반복문(iterative) 방식과 재귀(recursive) 방식 모두로 구현가능

### 반복문
```java
int binarySearch(int[] arr, int target) {
    int left = 0;
    int right = arr.length - 1;

    while (left <= right) {
        int mid = (left + right) / 2; // 중간 인덱스
        if (arr[mid] == target)
            return mid; // 찾음
        else if (arr[mid] < target)
            left = mid + 1; // 오른쪽 탐색
        else
            right = mid - 1; // 왼쪽 탐색
    }
    return -1; // 찾지 못한 경우
}
```

### 재귀
```java
int binarySearchRecursive(int[] arr, int left, int right, int target) {
    if (left > right) return -1;
    int mid = (left + right) / 2;

    if (arr[mid] == target) return mid;
    else if (arr[mid] < target)
        return binarySearchRecursive(arr, mid + 1, right, target);
    else
        return binarySearchRecursive(arr, left, mid - 1, target);
}
```

## 시간 복잡도
| 경우          | 시간 복잡도   |
| ----------- | -------- |
| 최선 (중간에 발견) | O(1)     |
| 평균 / 최악     | O(log N) |

## 전제 조건
배열이 반드시 오름차순(또는 내림차순)으로 정렬되어 있어야 한다.

